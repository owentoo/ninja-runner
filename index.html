<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Ninja Runner — 1280×720 Responsive + Mobile Fullscreen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    html, body { margin:0; height:100%; background:#000; }
    /* Full-viewport container; svh avoids iOS URL bar jumps */
    #game-root { width: 100vw; height: 100svh; display:flex; align-items:center; justify-content:center; }
    .hint { font: 12px/1.4 monospace; color: #ccc; text-align:center; margin: 6px 0 0; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game-root">
    <canvas id="game"></canvas>
  </div>
  <div class="hint">Desktop: ↑/SPACE jump • X/click throw • R restart — Mobile: left tap = jump, right tap = throw</div>

<script>
(() => {
  // ---------- Design space (16:9) ----------
  const W = 1280, H = 720;               // physics/game units
  // Keep proportions from your stable 800×300 build
  const GROUND_Y = Math.round(H * (250/300));   // ≈ 600 at 720h (same 0.8333)
  const FRAME = { w: 48, h: 48, ptero: { w: 48, h: 24 } };

  // ---------- Gameplay constants (unchanged feel) ----------
  const SPEED = 300, GRAVITY = 1400, JUMP_VELOCITY = -520;
  const OBSTACLE_BASE_INTERVAL = 1200;
  const MAX_DIFF = 8, DIFF_EVERY_MS = 15000, SPEED_STEP = 25, INTERVAL_FACTOR = 0.92;
  const SHURIKEN_SPEED_BASE = 600;
  const GROUND_ENEMY_PROBABILITY = 0.45;
  const PARALLAX = { clouds:0.20, mountains:0.35, hills:0.55, groundBack:0.95, groundFront:1.15 };
  const COYOTE_TIME_MS = 120, JUMP_BUFFER_MS = 120, JUMP_CUTOFF_FACTOR = 0.5;
  const SHURIKEN_SPIN_RPS = 3.0, SHURIKEN_SPIN_VARIANCE = 1.0;

  // Visual sizes scaled from old 300h baseline → proportional to H
  const SHURIKEN_DISPLAY = Math.round(H * (20/300));  // 48→20@300h => 48 at 720h
  const SHURIKEN_BODY    = Math.round(H * (16/300));
  const BODY_W = Math.round(H * (36/300));
  const BODY_H = Math.round(H * (50/300));
  const BODY_OFF_X = Math.round(H * (6/300));
  const BODY_OFF_Y = Math.round(H * (5/300));

  // Power-up
  const POWERUP_SPEED_MULT = 5.0, POWERUP_DURATION_MS = 6000, POWERUP_WARN_MS = 1000;
  const COLLECTIBLE_BASE_INTERVAL = 10000, COLLECTIBLE_INTERVAL_JITTER = 4000;

  // ---------- DPR-aware asset bucket ----------
  const DPR = Math.min(window.devicePixelRatio || 1, 3);
  function pickScaleBucket() {
    const vw = window.innerWidth, vh = window.innerHeight;
    const fitScale = Math.min(vw / W, vh / H);     // Scale Manager FIT approximation
    const effective = DPR * fitScale;
    if (effective >= 2.2) return { dir:'@3x', factor:3 };
    if (effective >= 1.4) return { dir:'@2x', factor:2 };
    return { dir:'@1x', factor:1 };
  }
  let ASSET = pickScaleBucket();

  // ---------- Phaser Game ----------
  new Phaser.Game({
    type: Phaser.CANVAS,
    canvas: document.getElementById('game'),
    backgroundColor: '#87ceeb',
    parent: 'game-root',
    physics: { default: 'arcade', arcade: { gravity: { y: GRAVITY }, debug: false } },
    scale: {
      parent: 'game-root',
      width: W,
      height: H,
      mode: Phaser.Scale.FIT,            // preserve aspect, letterbox when needed
      autoCenter: Phaser.Scale.CENTER_BOTH,
      // Optional: sane caps; increase if you add higher-res art later
      min: { width: 640, height: 360 },
      max: { width: 2560, height: 1440 }
    },
    scene: { preload, create, update }
  });

  // ---------- Placeholder makers (unchanged) ----------
  function solid(scene, key, w, h, color) {
    const g = scene.add.graphics();
    g.fillStyle(color, 1).fillRect(0,0,w,h);
    g.generateTexture(key, w, h);
    g.destroy();
  }
  function makePattern(scene, key, w, h, baseColor, stripeColor, stripeStep=6, stripeAlpha=0.18) {
    const g = scene.add.graphics();
    g.fillStyle(baseColor, 1).fillRect(0,0,w,h);
    g.lineStyle(1, stripeColor, stripeAlpha);
    for (let y=stripeStep; y<h; y+=stripeStep) g.strokeLineShape(new Phaser.Geom.Line(0,y,w,y));
    g.generateTexture(key, w, h); g.destroy();
  }
  function makeCrate(scene) {
    const key='crateRect', w=48, h=48, b=1;
    const g = scene.add.graphics();
    g.fillStyle(0x8a6f3b, 1).fillRect(0,0,w,h);
    g.lineStyle(3, 0x3f2d14, 1).strokeRect(b,b,w-2*b,h-2*b);
    g.generateTexture(key, w, h); g.destroy();
  }
  function makeCollectibleTex(scene) {
    const key='collectible';
    const size = Math.round(H * (20/300));
    const g = scene.add.graphics();
    g.fillStyle(0xfff066, 1).fillCircle(size/2, size/2, size/2);
    g.lineStyle(2, 0xffb200, 1).strokeCircle(size/2, size/2, (size/2)-1);
    g.generateTexture(key, size, size);
    g.destroy();
  }

  // ---------- Preload ----------
  function preload() {
    // tiny pixel for bullets/floor & particles
    solid(this, 'px', 2, 2, 0x000000);

    const base = `assets/${ASSET.dir}/`;
    // Background / ground (provide @1x/@2x/@3x files; FIT handles scaling)
    this.load.image('bgClouds',       base + 'bg_clouds.png');
    this.load.image('bgMountains',    base + 'bg_mountains.png');
    this.load.image('bgHills',        base + 'bg_hills.png');
    this.load.image('groundBackTile', base + 'ground_back_tile.png');
    this.load.image('groundFrontTile',base + 'ground_front_tile.png');

    // Spritesheets (frame sizes scaled by factor)
    const fw = 48 * ASSET.factor, fh = 55 * ASSET.factor;
    this.load.spritesheet('ninjaRun', base + 'ninja_run.png',       { frameWidth: fw, frameHeight: fh });
    this.load.spritesheet('enemyRun', base + 'ninja_run_enemy.png', { frameWidth: fw, frameHeight: fh });

    // Shuriken / banner / collectible
    this.load.image('shuriken',    base + 'shuriken.png');
    this.load.image('superBanner', base + 'super.png');

    // Arms placeholders
    solid(this, 'arms0', FRAME.w, FRAME.h, 0xff8a8a);
    solid(this, 'arms1', FRAME.w, FRAME.h, 0xff8a8a);
    solid(this, 'armsThrow0', FRAME.w, FRAME.h, 0xff5252);
    solid(this, 'armsThrow1', FRAME.w, FRAME.h, 0xff5252);

    // Obstacle placeholders & ptero frames
    solid(this, 'cactusRect', 16, 26, 0x000000);
    makeCrate(this);
    solid(this, 'ptero0', FRAME.ptero.w, FRAME.ptero.h, 0x000000);
    solid(this, 'ptero1', FRAME.ptero.w, FRAME.ptero.h, 0x000000);

    // Collectible placeholder; override if actual file exists
    makeCollectibleTex(this);
    this.load.image('collectible', base + 'collectible.png');
  }

  // ---------- Create ----------
  function ensureBGAndGroundTextures(s) {
    if (!s.textures.exists('bgClouds'))    makePattern(s, 'bgClouds', 256, 80, 0xffffff, 0x000000, 8, 0.10);
    if (!s.textures.exists('bgMountains')) makePattern(s, 'bgMountains',256, 90, 0xa0b1c2,0x000000,10, 0.12);
    if (!s.textures.exists('bgHills'))     makePattern(s, 'bgHills',    256, 70, 0x7b8fa6,0x000000, 8, 0.12);
    if (!s.textures.exists('groundBackTile'))  makePattern(s, 'groundBackTile', 128, Math.round(H*0.06), 0x8b5a2b, 0x000000, 6, 0.18);
    if (!s.textures.exists('groundFrontTile')) makePattern(s, 'groundFrontTile',128, Math.round(H*0.0933), 0x6b3f1f, 0x000000, 6, 0.20);
  }

  function create() {
    const s = this;

    ensureBGAndGroundTextures(s);

    // Scene state
    s.gameOver=false; s.throwing=false; s.score=0;
    s.difficulty=0; s.worldSpeed=SPEED; s.startTime=s.time.now;
    s.speedMult = 1.0; s._prevSpeedMult = 1.0; s.invincible = false;
    s.isTouchDevice = s.sys.game.device.input.touch;
    s.awaitingFirstTap = !!s.isTouchDevice;

    // Parallax layers — positions scaled from old 300h baseline:
    // clouds y=60(0.2H), mountains y=90(0.3H), hills y=130(0.433H)
    s.bgClouds    = s.add.tileSprite(0, Math.round(H*0.20),  W*2, Math.round(H*0.2667), 'bgClouds').setOrigin(0,0).setDepth(0).setScrollFactor(0);
    s.bgMountains = s.add.tileSprite(0, Math.round(H*0.30),  W*2, Math.round(H*0.30),   'bgMountains').setOrigin(0,0).setDepth(1).setScrollFactor(0);
    s.bgHills     = s.add.tileSprite(0, Math.round(H*0.433), W*2, Math.round(H*0.2333), 'bgHills').setOrigin(0,0).setDepth(2).setScrollFactor(0);

    // SUPER banner up to ground
    s.superBanner = s.add.tileSprite(0, 0, W*2, GROUND_Y, 'superBanner')
      .setOrigin(0,0).setDepth(2.6).setVisible(false).setAlpha(0.9).setScrollFactor(0);

    // Ground strips (heights scaled)
    s.groundBack  = s.add.tileSprite(0, GROUND_Y - Math.round(H*0.0267), W*2, Math.round(H*0.06),   'groundBackTile').setOrigin(0,0).setDepth(3.0).setScrollFactor(0);
    s.groundFront = s.add.tileSprite(0, GROUND_Y - Math.round(H*0.0067), W*2, Math.round(H*0.0933), 'groundFrontTile').setOrigin(0,0).setDepth(3.2).setScrollFactor(0);

    // Floor collider
    const floor = s.physics.add.staticImage(W/2, GROUND_Y+1, 'px').setDisplaySize(W,4).refreshBody();

    // Player
    s.player = s.physics.add.sprite(Math.round(W*0.09375), GROUND_Y, 'ninjaRun', 0) // 120/1280 = 0.09375
      .setOrigin(0.5,1).setCollideWorldBounds(true);
    s.player.body.setSize(BODY_W, BODY_H).setOffset(BODY_OFF_X, BODY_OFF_Y);
    s.physics.add.collider(s.player, floor);
    s.player.setDepth(4.5);

    // Arms overlay
    s.arms = s.add.sprite(s.player.x, s.player.y, 'arms0').setOrigin(0.5,1).setDepth(4.6).setVisible(false);
    s.events.on('update', ()=>{ s.arms.x = s.player.x; s.arms.y = s.player.y; });

    // Trail particles
    s.trailParticles = s.add.particles(0, 0, 'px', {
      lifespan: 220, speed: 0, quantity: 1, frequency: 22,
      scale: { start: 1.1, end: 0 }, alpha: { start: 0.65, end: 0 },
      tint: 0x8ef1ff, follow: s.player, blendMode: 'ADD'
    });
    s.trailParticles.stop();

    // Anims
    s.anims.create({ key:'base-run',  frames:s.anims.generateFrameNumbers('ninjaRun', { start:0, end:7 }),  frameRate:12, repeat:-1 });
    s.anims.create({ key:'enemy-run', frames:s.anims.generateFrameNumbers('enemyRun',{ start:0, end:7 }),  frameRate:12, repeat:-1 });
    s.anims.create({ key:'arms-throw',frames:[{key:'armsThrow0'},{key:'armsThrow1'}], frameRate:12, repeat:0 });
    s.anims.create({ key:'ptero-fly', frames:[{key:'ptero0'},{key:'ptero1'}], frameRate:8, repeat:-1 });

    // Groups
    s.obstacles   = s.physics.add.group({ allowGravity:false, immovable:true });
    s.collectibles= s.physics.add.group({ allowGravity:false, immovable:true });
    s.shurikens   = s.physics.add.group({ maxSize: 12 });

    // Portrait block
    buildOrientationGate(s);

    // Desktop input
    s.cursors = s.input.keyboard.createCursorKeys();
    const keyX = s.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.X);
    const keyR = s.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
    keyX.on('down', () => doThrow(s));
    s.input.on('pointerdown', () => { if (!s.awaitingFirstTap) doThrow(s); });
    keyR.on('down', () => { if (s.gameOver) s.scene.restart(); });

    // Jump bookkeeping
    s.lastOnGroundAt = s.time.now;
    s.jumpQueuedAt   = -Infinity;
    s.jumpReleased   = false;
    s.input.keyboard.on('keydown-UP',    ()=>{ s.jumpQueuedAt = s.time.now; });
    s.input.keyboard.on('keydown-SPACE', ()=>{ s.jumpQueuedAt = s.time.now; });
    s.input.keyboard.on('keyup-UP',      ()=>{ s.jumpReleased = true;       });
    s.input.keyboard.on('keyup-SPACE',   ()=>{ s.jumpReleased = true;       });

    // UI
    s.scoreText   = s.add.text(14, 12, 'SCORE 0', { fontFamily:'monospace', fontSize:16, color:'#000' }).setDepth(10).setScrollFactor(0);
    s.gameOverTxt = s.add.text(W/2, H/2 - 10, '', { fontFamily:'monospace', fontSize:20, color:'#000' }).setOrigin(0.5).setDepth(10).setScrollFactor(0);
    s.restartTxt  = s.add.text(W/2, H/2 + 16, '', { fontFamily:'monospace', fontSize:14, color:'#000' }).setOrigin(0.5).setDepth(10).setScrollFactor(0);

    // Collisions / contacts
    s.physics.add.overlap(s.shurikens, s.obstacles, (b,o)=>{
      if (!b.active || !o.active) return;
      if (o.getData('hit')) { b.destroy(); return; }
      b.destroy();
      if (o.getData('destructible')) {
        o.setData('hit', true);
        o.setTint(0xffff66);
        s.time.delayedCall(60, ()=>{
          if (o.active) o.destroy();
          s.score += (3 + s.difficulty * 0.5);
        });
      }
    });
    s._obstacleCollider = s.physics.add.collider(s.player, s.obstacles, () => { if (!s.invincible) endGame(s); });
    s.physics.add.overlap(s.player, s.obstacles, (_, o) => { if (s.invincible) zapObstacle(s, o); });
    s.physics.add.overlap(s.player, s.collectibles, (_, item)=>{ if (!item.active) return; item.destroy(); activatePowerUp(s); });

    // Spawners
    s.nextSpawn = 0;
    s.nextCollectible = s.time.now + collectibleInterval();

    // First tap overlay (mobile)
    if (s.awaitingFirstTap) {
      s.physics.world.pause();
      buildFirstTapOverlay(s);
    } else {
      s.player.play('base-run');
    }
  }

  // ---------- Overlays & HUD ----------
  function buildFirstTapOverlay(s) {
    const overlay = s.add.container(0,0).setDepth(900).setScrollFactor(0);
    const bg  = s.add.rectangle(0,0,W,H,0x000000,0.45).setOrigin(0,0).setInteractive();
    const box = s.add.rectangle(W/2,H/2, Math.min(520,W*0.9), 120, 0xffffff, 0.95).setStrokeStyle(2,0x000000,0.6);
    const txt = s.add.text(W/2,H/2, 'Tap to play\n(also enters fullscreen)', { fontFamily:'monospace', fontSize: 16, color:'#000', align:'center' }).setOrigin(0.5);
    overlay.add([bg,box,txt]);

    const layout = ()=>{ bg.setSize(W,H); box.setPosition(W/2,H/2).setSize(Math.min(520,W*0.9),120); txt.setPosition(W/2,H/2); };
    layout(); s.scale.on('resize', layout);

    const startFromTap = () => {
      if (!s.scale.isFullscreen) s.scale.startFullscreen().catch(()=>{});
      s.awaitingFirstTap = false;
      overlay.destroy();
      s.physics.world.resume();
      s.player.play('base-run');

      // Build mobile HUD after gesture
      if (s.isTouchDevice) buildMobileHUD(s);
    };
    [bg,box,txt].forEach(obj => obj.on('pointerdown', startFromTap));
  }

  function buildOrientationGate(s) {
    const overlay = s.add.container(0,0).setDepth(1000).setScrollFactor(0);
    const bg  = s.add.rectangle(0,0,W,H,0x000000,0.55).setOrigin(0,0).setInteractive();
    const box = s.add.rectangle(W/2,H/2, Math.min(560,W*0.9), 120, 0xffffff, 0.95).setStrokeStyle(2,0x000000,0.6);
    const txt = s.add.text(W/2,H/2, 'Rotate your device to landscape for the best experience', {
      fontFamily:'monospace', fontSize:16, color:'#000', align:'center', wordWrap:{ width: Math.min(520,W*0.85) }
    }).setOrigin(0.5);
    overlay.add([bg,box,txt]);

    const layout = ()=>{ bg.setSize(W,H); box.setPosition(W/2,H/2).setSize(Math.min(560,W*0.9),120); txt.setPosition(W/2,H/2).setWordWrapWidth(Math.min(520,W*0.85), true); };
    const show = v => overlay.setVisible(v);
    layout(); show(s.scale.orientation === Phaser.Scale.PORTRAIT);
    s.scale.on('orientationchange', o => { show(o === Phaser.Scale.PORTRAIT); layout(); });
    s.scale.on('resize', layout);
  }

  function buildMobileHUD(s) {
    const hud = s.add.container(0,0).setDepth(20).setScrollFactor(0);

    const tut = s.add.text(W/2, 24, 'Tap left to JUMP • Tap right to THROW', { fontFamily:'monospace', fontSize: 16, color:'#000' }).setOrigin(0.5,0).setAlpha(0.9);
    hud.add(tut);
    s.time.delayedCall(3000, ()=> s.tweens.add({ targets: tut, alpha: 0, duration: 600, onComplete: ()=>tut.destroy() }));

    const leftZone = s.add.rectangle(0,0, W*0.5, H, 0x000000, 0.0001).setOrigin(0,0).setInteractive({ useHandCursor:true });
    leftZone.on('pointerdown', ()=>{ s.jumpQueuedAt = s.time.now; });
    leftZone.on('pointerup',   ()=>{ s.jumpReleased = true; });
    leftZone.on('pointerout',  ()=>{ s.jumpReleased = true; });
    hud.add(leftZone);

    const rightZone = s.add.rectangle(W*0.5,0, W*0.5, H, 0x000000, 0.0001).setOrigin(0,0).setInteractive({ useHandCursor:true });
    rightZone.on('pointerdown', ()=> doThrow(s));
    hud.add(rightZone);

    const rBtn = s.add.circle(W - 42, H - 42, 22, 0x000000, 0.12).setStrokeStyle(2, 0x000000, 0.5).setInteractive({ useHandCursor:true });
    const rTxt = s.add.text(W - 42, H - 42, 'R', { fontFamily:'monospace', fontSize: 18, color:'#000' }).setOrigin(0.5);
    rBtn.on('pointerdown', ()=> { if (s.gameOver) s.scene.restart(); });
    hud.add([rBtn,rTxt]);

    const fsBtn = s.add.rectangle(W - 42, 42, 28, 28, 0x000000, 0.10).setStrokeStyle(2, 0x000000, 0.5).setInteractive({ useHandCursor:true });
    const fsTxt = s.add.text(W - 42, 42, '⛶', { fontFamily:'monospace', fontSize: 16, color:'#000' }).setOrigin(0.5);
    fsBtn.on('pointerdown', ()=> { if (!s.scale.isFullscreen) s.scale.startFullscreen(); else s.scale.stopFullscreen(); });
    hud.add([fsBtn,fsTxt]);

    const layoutHUD = ()=> {
      rBtn.setPosition(W-42, H-42); rTxt.setPosition(W-42, H-42);
      fsBtn.setPosition(W-42, 42);  fsTxt.setPosition(W-42, 42);
      leftZone.setPosition(0,0).setSize(W*0.5, H);
      rightZone.setPosition(W*0.5,0).setSize(W*0.5, H);
    };
    layoutHUD(); s.scale.on('resize', layoutHUD);

    s.events.on('update', ()=> rBtn.setAlpha(s.gameOver ? 1.0 : 0.35));
  }

  // ---------- Helpers ----------
  function collectibleInterval() {
    return COLLECTIBLE_BASE_INTERVAL + Phaser.Math.Between(-COLLECTIBLE_INTERVAL_JITTER, COLLECTIBLE_INTERVAL_JITTER);
  }

  function endGame(s) {
    if (s.gameOver) return;
    s.gameOver = true;
    s.physics.world.pause();
    s.player.anims.pause();
    s.arms.anims.pause();
    s.obstacles.children.each(o => { if (o.body) o.body.enable = false; });
    s.shurikens.children.each(b => { if (b.body) b.body.enable = false; });
    s.collectibles.children.each(c => { if (c.body) c.body.enable = false; });
    stopBlink(s);
    s.superBanner.setVisible(false);
    s.player.clearTint();
    s.invincible = false;
    s.speedMult = 1.0;
    if (s.trailParticles) s.trailParticles.stop();
    s.gameOverTxt.setText('GAME OVER');
    s.restartTxt.setText('Press R to Restart');
  }

  function zapObstacle(s, o) {
    if (!o || !o.active) return;
    o.setTint(0x99fffd);
    s.time.delayedCall(40, ()=>{ if (o.active) o.destroy(); });
    s.score += 2;
  }

  function activatePowerUp(s) {
    if (s.invincible) {
      if (s._powerupTimer) s._powerupTimer.remove(false);
      if (s._warnTimer) s._warnTimer.remove(false);
      stopBlink(s);
      s._powerupTimer = s.time.delayedCall(POWERUP_DURATION_MS, ()=>deactivatePowerUp(s));
      s._warnTimer    = s.time.delayedCall(Math.max(0, POWERUP_DURATION_MS - POWERUP_WARN_MS), ()=>startBlink(s));
      if (s.trailParticles) s.trailParticles.start();
      if (s._obstacleCollider) s._obstacleCollider.active = false;
      return;
    }
    s.invincible = true;
    s.speedMult = POWERUP_SPEED_MULT;
    s.player.setTint(0x8ef1ff);
    s.superBanner.setVisible(true);
    if (s.trailParticles) s.trailParticles.start();
    if (s._obstacleCollider) s._obstacleCollider.active = false;
    rescaleMoversForSpeedChange(s, s._prevSpeedMult, s.speedMult);
    s._powerupTimer = s.time.delayedCall(POWERUP_DURATION_MS, ()=>deactivatePowerUp(s));
    s._warnTimer    = s.time.delayedCall(Math.max(0, POWERUP_DURATION_MS - POWERUP_WARN_MS), ()=>startBlink(s));
  }

  function deactivatePowerUp(s) {
    s.invincible = false;
    s.speedMult = 1.0;
    s.player.clearTint();
    s.superBanner.setVisible(false);
    if (s.trailParticles) s.trailParticles.stop();
    if (s._obstacleCollider) s._obstacleCollider.active = true;
    if (s._powerupTimer) s._powerupTimer.remove(false);
    if (s._warnTimer) s._warnTimer.remove(false);
    stopBlink(s);
    rescaleMoversForSpeedChange(s, s._prevSpeedMult, s.speedMult);
  }

  function startBlink(s) {
    stopBlink(s);
    s._blinkTweenPlayer = s.tweens.add({ targets: s.player,      alpha: 0.45, duration: 120, yoyo: true, repeat: Math.ceil(POWERUP_WARN_MS/240)*2 });
    s._blinkTweenBanner = s.tweens.add({ targets: s.superBanner, alpha: 0.4,  duration: 120, yoyo: true, repeat: Math.ceil(POWERUP_WARN_MS/240)*2 });
  }
  function stopBlink(s) {
    if (s._blinkTweenPlayer) { s._blinkTweenPlayer.stop(); s._blinkTweenPlayer = null; }
    if (s._blinkTweenBanner) { s._blinkTweenBanner.stop(); s._blinkTweenBanner = null; }
    if (s.player) s.player.setAlpha(1);
    if (s.superBanner) s.superBanner.setAlpha(0.9);
  }

  function rescaleMoversForSpeedChange(s, prevMult, newMult) {
    if (prevMult === newMult) return;
    const scale = newMult / prevMult;
    s.obstacles.children.each(o => { if (o.active && o.body && o.body.velocity) o.body.velocity.x *= scale; });
    s.collectibles.children.each(c => { if (c.active && c.body && c.body.velocity) c.body.velocity.x *= scale; });
    s.shurikens.children.each(b => { if (b.active && b.body && b.body.velocity) b.body.velocity.x *= scale; });
    s._prevSpeedMult = newMult;
  }

  // ---------- Spawns ----------
  function createGroundObstacle(s) {
    const makeEnemy = Math.random() < GROUND_ENEMY_PROBABILITY;
    if (makeEnemy) {
      const e = s.obstacles.create(W + 20, GROUND_Y, 'enemyRun', 0).setOrigin(0.5,1).setDepth(4.2);
      e.play('enemy-run');
      e.setVelocityX(-(s.worldSpeed * s.speedMult));
      e.body.setSize(BODY_W, BODY_H).setOffset(BODY_OFF_X, BODY_OFF_Y);
      e.setData('destructible', true);
      return e;
    } else {
      const c = s.obstacles.create(W + 20, GROUND_Y, 'cactusRect').setOrigin(0.5,1).setDepth(4.2);
      c.setVelocityX(-(s.worldSpeed * s.speedMult));
      c.body.setSize(c.width, c.height).setOffset(0,0);
      c.setData('destructible', false);
      return c;
    }
  }
  function createFlyingObstacle(s) {
    const f = s.obstacles.create(W + 20, Phaser.Math.Between(GROUND_Y - Math.round(H*0.3667), GROUND_Y - Math.round(H*0.2)), 'ptero0')
      .setOrigin(0.5,1).setDepth(4.2);
    f.play('ptero-fly');
    f.setVelocityX(-Phaser.Math.Between(s.worldSpeed-30, s.worldSpeed+50) * s.speedMult);
    f.setData('destructible', true);
    return f;
  }
  function spawnObstacle(s) {
    (Math.random() < 0.65) ? createGroundObstacle(s) : createFlyingObstacle(s);
  }
  function spawnCollectible(s) {
    const y = Phaser.Math.Between(GROUND_Y - Math.round(H*0.30), GROUND_Y - Math.round(H*0.20));
    const item = s.collectibles.create(W + 20, y, 'collectible').setOrigin(0.5,0.5).setDepth(4.0);
    item.setVelocityX(-(s.worldSpeed * s.speedMult));
    item.setScale(1.1);
    s.tweens.add({ targets: item, scale: 1.0, yoyo: true, duration: 400, repeat: -1 });
    return item;
  }
  function spawnShuriken(s) {
    if (s.shurikens.countActive(true) >= s.shurikens.maxSize) return;
    const THROW_OFFSET = { x: Math.round(W*(14/800)), y: -Math.round(H*(38/300)) };
    const b = s.shurikens.get(s.player.x + THROW_OFFSET.x, s.player.y + THROW_OFFSET.y, 'shuriken');
    if (!b) return;
    const speed = (SHURIKEN_SPEED_BASE + s.difficulty * 20) * s.speedMult;
    b.setActive(true).setVisible(true).setOrigin(0.5);
    b.setDisplaySize(SHURIKEN_DISPLAY, SHURIKEN_DISPLAY);
    s.physics.world.enable(b);
    b.body.setAllowGravity(false);
    b.body.setSize(SHURIKEN_BODY, SHURIKEN_BODY).setOffset(
      Math.round((SHURIKEN_DISPLAY - SHURIKEN_BODY)/2),
      Math.round((SHURIKEN_DISPLAY - SHURIKEN_BODY)/2)
    );
    b.setVelocityX(speed);
    b.setDepth(4.3);
    const rps = SHURIKEN_SPIN_RPS + Phaser.Math.FloatBetween(-SHURIKEN_SPIN_VARIANCE, SHURIKEN_SPIN_VARIANCE);
    b.rotationSpeed = rps * Math.PI * 2;
    s.time.delayedCall(2500, ()=>{ if (b && b.active) b.destroy(); });
  }
  function doThrow(s) {
    if (s.gameOver || s.throwing) return;
    s.throwing = true;
    s.arms.setVisible(true);
    s.arms.anims.play('arms-throw', true);
    s.time.delayedCall(90, ()=> spawnShuriken(s));
    s.arms.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
      if (s.gameOver) return;
      s.throwing = false;
      s.arms.setVisible(false);
    });
  }

  // ---------- Update ----------
  function update(time, delta) {
    const s = this;
    if (s.awaitingFirstTap || s.gameOver) return;

    const elapsed = s.time.now - s.startTime;
    s.difficulty = Math.min(MAX_DIFF, Math.floor(elapsed / DIFF_EVERY_MS));
    s.worldSpeed = SPEED + s.difficulty * SPEED_STEP;

    const dt = delta / 1000;
    const scroll = s.worldSpeed * s.speedMult;
    s.bgClouds.tilePositionX    += (scroll * PARALLAX.clouds)     * dt;
    s.bgMountains.tilePositionX += (scroll * PARALLAX.mountains)  * dt;
    s.bgHills.tilePositionX     += (scroll * PARALLAX.hills)      * dt;
    if (s.superBanner.visible)    s.superBanner.tilePositionX      += (scroll * 0.90) * dt;
    s.groundBack.tilePositionX   += (scroll * PARALLAX.groundBack) * dt;
    s.groundFront.tilePositionX  += (scroll * PARALLAX.groundFront)* dt;

    // Coyote + jump buffer + variable jump
    const now = s.time.now;
    if (s.player.body.blocked.down) s.lastOnGroundAt = now;
    if ((s.cursors.up.isDown || s.cursors.space.isDown) && (now - s.jumpQueuedAt) > 20) s.jumpQueuedAt = now;
    const canCoyote   = (now - s.lastOnGroundAt) <= COYOTE_TIME_MS;
    const hasBuffered = (now - s.jumpQueuedAt)   <= JUMP_BUFFER_MS;
    if (hasBuffered && (s.player.body.blocked.down || canCoyote)) {
      s.player.setVelocityY(JUMP_VELOCITY);
      s.jumpQueuedAt = -Infinity;
    }
    if (s.jumpReleased && s.player.body.velocity.y < 0) {
      s.player.setVelocityY(s.player.body.velocity.y * JUMP_CUTOFF_FACTOR);
      s.jumpReleased = false;
    }

    // Shurikens
    s.shurikens.children.each(b => {
      if (!b.active) return;
      b.rotation += (b.rotationSpeed || 0) * dt;
      if (b.x > W + 40) b.destroy();
    });

    // Spawns
    if (time > s.nextSpawn) {
      spawnObstacle(s);
      const levelInterval = OBSTACLE_BASE_INTERVAL * Math.pow(INTERVAL_FACTOR, s.difficulty);
      s.nextSpawn = time + levelInterval + Phaser.Math.Between(-300, 300);
    }
    if (now > s.nextCollectible) {
      spawnCollectible(s);
      s.nextCollectible = now + collectibleInterval();
    }

    // Cleanup + score
    s.obstacles.children.each(o => { if (o.active && o.x < -40) { o.destroy(); s.score += (1 + s.difficulty * 0.1); } });
    s.collectibles.children.each(c => { if (c.active && c.x < -40) c.destroy(); });

    s.scoreText.setText('SCORE ' + Math.floor(s.score));
  }
})();
</script>
</body>
</html>
