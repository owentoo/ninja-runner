<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Ninja Runner — Single Ground Plane</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <style>
    html, body { height: 100%; margin: 0; background: #d9d9d9; }
    #game-outer {
      position: relative; width: 100svw; height: 100svh;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden; background: transparent;
    }
    #stage {
      position: relative; width: min(100%, 1100px); aspect-ratio: 1280 / 592;
      height: auto; display: grid; place-items: center;
      background: #d9d9d9; box-shadow: inset 0 0 0 2px #b5b5b5; border-radius: 6px;
    }
    #game-outer.fs #stage { width: 100svw; height: 100svh; aspect-ratio: auto; border-radius: 0; box-shadow: none; }
    canvas { display: block; }

    /* Full-panel overlays */
    .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center;
      z-index: 10; text-align: center; background: rgba(0,0,0,.60); backdrop-filter: blur(4px); pointer-events: auto; }
    .overlay.show { display: flex; }
    .sheet { max-width: 560px; padding: 18px 16px; border-radius: 14px; background: rgba(0,0,0,.78); color: #fff;
      border: 1px solid rgba(255,255,255,.18); font: 600 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto; }
    .sheet h2 { margin: 0 0 8px; font-size: 20px; } .sheet p { margin: 8px 0; font-weight: 500; }
    .cta { margin-top: 12px; padding: 10px 14px; border: 0; border-radius: 12px; font: 600 14px/1 system-ui,-apple-system,Segoe UI,Roboto; background:#00b894; color:#0b1b16; cursor:pointer; }

    #fs-btn { position: absolute; right: 10px; top: 10px; z-index: 11; padding: 8px 10px; border: 0; border-radius: 12px;
      font: 12px/1 system-ui,-apple-system,Segoe UI,Roboto; background: #000; color: #fff; opacity: .95; cursor: pointer; display: none; touch-action: manipulation; }
    #fs-btn.show { display: inline-block; }

    .hint { font: 12px/1.4 monospace; color: #333; text-align: center; padding: 6px 10px; background:#f2f2f2; }
    #rotate-overlay .sheet { background: rgba(0,0,0,.85); }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game-outer">
    <div id="stage">
      <canvas id="game"></canvas>

      <div id="splash-1" class="overlay show">
        <div class="sheet">
          <h2>Ninja Runner</h2>
          <p>Tap the screen or press <b>Space</b> to begin</p>
          <p style="opacity:.75;margin-top:4px;">(You’ll see the controls next)</p>
          <button id="splash-1-next" class="cta" style="margin-top:12px;">Continue</button>
        </div>
      </div>

      <div id="splash-2" class="overlay">
        <div class="sheet">
          <h2>How to Play</h2>
          <p>Jump: <b>↑</b> / <b>Space</b> / <b>Tap Left Half</b></p>
          <p>Throw: <b>X</b> / <b>Tap Right Half</b></p>
          <p>Restart: <b>Space</b> (desktop) or <b>Tap</b> (mobile)</p>
          <button id="start-cta" class="cta">Start</button>
        </div>
      </div>

      <div id="gameover" class="overlay">
        <div class="sheet">
          <h2>Game Over</h2>
          <p>Your Score: <b id="final-score">0</b></p>
          <button id="restart-cta" class="cta">Restart</button>
        </div>
      </div>

      <div id="rotate-overlay" class="overlay" role="dialog" aria-live="assertive">
        <div class="sheet">
          <h2>Rotate to Landscape</h2>
          <p>Turn your device sideways, or tap Fullscreen.</p>
        </div>
      </div>

      <button id="fs-btn" aria-label="Enter fullscreen">⤢ Fullscreen</button>
    </div>
  </div>

  <div class="hint">↑/SPACE = jump • X/right half = throw • Space/Tap to restart</div>

<script>
(() => {
  // ======= CANVAS SPACE =======
  const W = 1280, H = 592;
  const BASE = { W: 1280, H: 592 };
  const sx = (n) => Math.round(n * (W / BASE.W));
  const sy = (n) => Math.round(n * (H / BASE.H));
  const su = (n) => Math.round(n * (H / BASE.H));

  // ======= SINGLE GROUND PLANE =======
  const GROUND = {
    y: Math.round(H * 0.833),                  // visual/physics ground line
    thickness: Math.max(10, sy(10))            // floor collider thickness
  };

  // ======= GLOBAL GEOMETRY SCALE (visuals + hitboxes) =======
  const GEOM_SCALE = 1.35; // change to taste (everything scales consistently)

  // Body sizes/offsets (all relative to the same ground)
  const PLAYER_BODY = { w: Math.round(su(36)*GEOM_SCALE), h: Math.round(su(50)*GEOM_SCALE), ox: Math.round(su(6)*GEOM_SCALE), oy: Math.round(su(5)*GEOM_SCALE) };
  const ENEMY_BODY  = { ...PLAYER_BODY };
  const CACTUS      = { w: Math.round(su(16)*GEOM_SCALE), h: Math.round(su(26)*GEOM_SCALE) };
  const PTERO       = { w: Math.round(su(48)*GEOM_SCALE), h: Math.round(su(24)*GEOM_SCALE) };
  const COLLECTIBLE = { w: Math.round(su(20)*GEOM_SCALE), h: Math.round(su(20)*GEOM_SCALE) };
  const SHURIKEN    = { disp: Math.round(su(20)*GEOM_SCALE), body: Math.round(su(16)*GEOM_SCALE) };
  const THROW_OFF   = { x: Math.round(sx(14)*GEOM_SCALE), y: -Math.round(sy(38)*GEOM_SCALE) };

  // ======= GAME CONSTANTS =======
  const SPEED = 300, GRAVITY = 1400, JUMP_VELOCITY = -520;
  const OBSTACLE_BASE_INTERVAL = 1200;
  const MAX_DIFF = 8, DIFF_EVERY_MS = 15000, SPEED_STEP = 25, INTERVAL_FACTOR = 0.92;
  const SHURIKEN_SPEED_BASE = 600;
  const GROUND_ENEMY_PROBABILITY = 0.45;
  const PARALLAX = { clouds:0.20, mountains:0.35, hills:0.55, groundBack:0.95, groundFront:1.15 };
  const COYOTE_TIME_MS = 120, JUMP_BUFFER_MS = 120, JUMP_CUTOFF_FACTOR = 0.5;

  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // DOM
  const outer = document.getElementById('game-outer');
  const rotate = document.getElementById('rotate-overlay');
  const splash1 = document.getElementById('splash-1');
  const splash2 = document.getElementById('splash-2');
  const gameover = document.getElementById('gameover');
  const splash1Next = document.getElementById('splash-1-next');
  const startCTA = document.getElementById('start-cta');
  const restartCTA = document.getElementById('restart-cta');
  const fsBtn = document.getElementById('fs-btn');
  const finalScoreEl = document.getElementById('final-score');

  const isMobile   = () => /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent);
  const isPortrait = () => window.matchMedia('(orientation: portrait)').matches;
  const show = (el) => el.classList.add('show');
  const hide = (el) => el.classList.remove('show');

  // Phaser
  let game, scene;
  game = new Phaser.Game({
    type: Phaser.CANVAS,
    backgroundColor: '#87ceeb',
    canvas: document.getElementById('game'),
    resolution: DPR,
    physics: { default: 'arcade', arcade: { gravity: { y: GRAVITY }, debug: false } },
    scale: { parent: 'stage', width: W, height: H, mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, fullscreenTarget: 'game-outer', expandParent: true },
    scene: { preload, create, update }
  });

  // Assets / placeholders
  function solid(scene, key, w, h, color){const g=scene.add.graphics();g.fillStyle(color,1).fillRect(0,0,w,h);g.generateTexture(key,w,h);g.destroy();}
  function makePattern(scene,key,w,h,base,stripe,step=6,a=0.18){const g=scene.add.graphics();g.fillStyle(base,1).fillRect(0,0,w,h);g.lineStyle(1,stripe,a);for(let y=step;y<h;y+=step)g.strokeLineShape(new Phaser.Geom.Line(0,y,w,y));g.generateTexture(key,w,h);g.destroy();}
  function makeCrate(scene){const g=scene.add.graphics();g.fillStyle(0x8a6f3b,1).fillRect(0,0,48,48);g.lineStyle(3,0x3f2d14,1).strokeRect(1,1,46,46);g.generateTexture('crateRect',48,48);g.destroy();}
  function makeCollectibleTex(scene){const size=20,g=scene.add.graphics();g.fillStyle(0xfff066,1).fillCircle(size/2,size/2,size/2);g.lineStyle(2,0xffb200,1).strokeCircle(size/2,size/2,(size/2)-1);g.generateTexture('collectible',size,size);g.destroy();}
  function preload(){
    solid(this,'px',2,2,0x000000);
    this.load.image('bgClouds','bg_clouds.png');
    this.load.image('bgMountains','bg_mountains.png');
    this.load.image('bgHills','bg_hills.png');
    this.load.image('groundBackTile','ground_back_tile.png');
    this.load.image('groundFrontTile','ground_front_tile.png');
    this.load.spritesheet('ninjaRun','ninja_run.png',{frameWidth:48,frameHeight:55});
    this.load.spritesheet('enemyRun','ninja_run_enemy.png',{frameWidth:48,frameHeight:55});
    this.load.image('shuriken','shuriken.png');
    this.load.image('superBanner','super.png');
    for (let i=0;i<2;i++) solid(this,'arms'+i,48,48,0xff8a8a);
    for (let i=0;i<2;i++) solid(this,'armsThrow'+i,48,48,0xff5252);
    solid(this,'cactusRect',16,26,0x000000);
    makeCrate(this);
    for (let i=0;i<2;i++) solid(this,'ptero'+i,48,24,0x000000);
    makeCollectibleTex(this);
    this.load.image('collectible','collectible.png');
  }
  function ensureBGAndGroundTextures(s){
    if (!s.textures.exists('bgClouds'))    makePattern(s,'bgClouds',256,Math.round(H*0.135),0xffffff,0x000000,8,0.10);
    if (!s.textures.exists('bgMountains')) makePattern(s,'bgMountains',256,Math.round(H*0.152),0xa0b1c2,0x000000,10,0.12);
    if (!s.textures.exists('bgHills'))     makePattern(s,'bgHills',256,Math.round(H*0.118),0x7b8fa6,0x000000,8,0.12);
    if (!s.textures.exists('groundBackTile'))  makePattern(s,'groundBackTile',128,Math.round(H*0.030),0x8b5a2b,0x000000,6,0.18);
    if (!s.textures.exists('groundFrontTile')) makePattern(s,'groundFrontTile',128,Math.round(H*0.047),0x6b3f1f,0x000000,6,0.20);
  }

  // Helpers bound to the ground plane
  const onGround = (spr) => spr.setOrigin(0.5,1).setY(GROUND.y);
  const tileAtGroundTop = (tile, h) => tile.setOrigin(0,1).setY(GROUND.y).setDisplaySize(W*2, h);

  // Scene
  function create(){
    const s=this; scene = s; ensureBGAndGroundTextures(s);

    // State
    s.gameStarted=false; s.gameOver=false; s.throwing=false; s.score=0;
    s.difficulty=0; s.worldSpeed=SPEED; s.startTime=s.time.now;
    s.speedMult=1.0; s._prevSpeedMult=1.0; s.invincible=false;

    // Parallax layers (visual; not tied to the ground)
    s.bgClouds    = s.add.tileSprite(0, Math.round(H*0.10), W*2, Math.round(H*0.135),'bgClouds').setOrigin(0,0).setDepth(0);
    s.bgMountains = s.add.tileSprite(0, Math.round(H*0.152),W*2, Math.round(H*0.152),'bgMountains').setOrigin(0,0).setDepth(1);
    s.bgHills     = s.add.tileSprite(0, Math.round(H*0.22), W*2, Math.round(H*0.118),'bgHills').setOrigin(0,0).setDepth(2);

    // Ground visuals aligned to the same ground line
    s.groundBack  = tileAtGroundTop(s.add.tileSprite(0,0,0,0,'groundBackTile').setDepth(3.0), sy(18));
    s.groundFront = tileAtGroundTop(s.add.tileSprite(0,0,0,0,'groundFrontTile').setDepth(3.2), sy(28));

    // Super banner fills down to the ground line
    s.superBanner = s.add.tileSprite(0,0,W*2,GROUND.y,'superBanner').setOrigin(0,1).setY(GROUND.y).setDepth(2.6).setVisible(false).setAlpha(0.9);

    // Physics floor centered under the ground line
    const floor = s.physics.add.staticImage(W/2, GROUND.y + Math.round(GROUND.thickness/2), 'px')
      .setDisplaySize(W, GROUND.thickness).refreshBody();

    // Player anchored to the ground plane
    s.player = s.physics.add.sprite(sx(120), GROUND.y, 'ninjaRun', 0)
      .setOrigin(0.5,1).setCollideWorldBounds(true).setDepth(4.5).setScale(GEOM_SCALE);
    s.player.body.setSize(PLAYER_BODY.w, PLAYER_BODY.h).setOffset(PLAYER_BODY.ox, PLAYER_BODY.oy);
    s.physics.add.collider(s.player, floor);

    // Anims
    s.anims.create({ key: 'base-run', frames: s.anims.generateFrameNumbers('ninjaRun', { start: 0, end: 7 }), frameRate: 12, repeat: -1 });
    s.anims.create({ key:'enemy-run', frames: s.anims.generateFrameNumbers('enemyRun', { start: 0, end: 7 }), frameRate: 12, repeat: -1 });
    s.anims.create({ key:'arms-throw',frames:[{key:'armsThrow0'},{key:'armsThrow1'}], frameRate:12, repeat:0 });
    s.anims.create({ key:'ptero-fly', frames:[{key:'ptero0'},{key:'ptero1'}], frameRate:8, repeat:-1 });
    s.player.play('base-run'); s.player.anims.pause();

    // Arms follow player (also on the ground plane)
    s.arms = s.add.sprite(s.player.x, s.player.y, 'arms0').setOrigin(0.5,1).setDepth(4.6).setVisible(false).setScale(GEOM_SCALE);
    s.events.on('update', ()=>{ s.arms.x = s.player.x; s.arms.y = s.player.y; });

    s.trailParticles = s.add.particles(0, 0, 'px', {
      lifespan: 220, speed: 0, quantity: 1, frequency: 22,
      scale: { start: 1.1 * GEOM_SCALE, end: 0 }, alpha: { start: 0.65, end: 0 },
      tint: 0x8ef1ff, follow: s.player, blendMode: 'ADD'
    }); s.trailParticles.stop();

    s.obstacles   = s.physics.add.group({ allowGravity:false, immovable:true });
    s.collectibles= s.physics.add.group({ allowGravity:false, immovable:true });
    s.shurikens   = s.physics.add.group({ maxSize: 12 });

    // Inputs (screen-space split, independent of zoom)
    s.cursors = s.input.keyboard.createCursorKeys();
    const keyX = s.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.X);

    s.input.on('pointerdown', (pointer) => {
      if (!s.gameStarted || s.gameOver) return;
      const isLeft = pointer.x < (s.cameras.main.width * 0.5);
      if (isLeft) s.jumpQueuedAt = s.time.now; else doThrow(s);
    });
    s.input.keyboard.on('keydown-UP',    ()=>{ if (s.gameStarted) s.jumpQueuedAt = s.time.now; });
    s.input.keyboard.on('keydown-SPACE', ()=>{
      if (!s.gameStarted && !s.gameOver && splash2.classList.contains('show')) { startRun(); return; }
      if (s.gameOver) { restartRun(); return; }
      if (s.gameStarted) s.jumpQueuedAt = s.time.now;
    });
    keyX.on('down', () => { if (s.gameStarted) doThrow(s); });

    // Jump flags
    s.lastOnGroundAt = s.time.now; s.jumpQueuedAt = -Infinity; s.jumpReleased = false;
    s.input.keyboard.on('keyup-UP',    ()=>{ s.jumpReleased = true; });
    s.input.keyboard.on('keyup-SPACE', ()=>{ s.jumpReleased = true; });

    s.scoreText = s.add.text(sx(14), sy(12), 'SCORE 0', { fontFamily:'monospace', fontSize:16, color:'#000' }).setDepth(10).setScale(GEOM_SCALE);

    // Collisions
    s._obstacleCollider = s.physics.add.collider(s.player, s.obstacles, (player, o) => { if (!s.invincible) endGame(s); });
    s.physics.add.overlap(s.player, s.obstacles, (player, o) => { if (s.invincible) zapObstacle(s, o); });
    s.physics.add.overlap(s.shurikens, s.obstacles, (b,o)=>{
      if (!b.active || !o.active) return;
      if (o.getData('hit')) { b.destroy(); return; }
      b.destroy();
      if (o.getData('destructible')) {
        o.setData('hit', true); o.setTint(0xffff66);
        s.time.delayedCall(60, ()=>{ if (o.active) o.destroy(); s.score += (3 + s.difficulty * 0.5); });
      }
    });
    s.physics.add.overlap(s.player, s.collectibles, (player, item)=>{
      if (!item.active) return; item.destroy(); activatePowerUp(s);
    });

    s.nextSpawn = 0;
    s.nextCollectible = s.time.now + collectibleInterval();

    // Start paused under overlays
    s.physics.world.pause();
  }

  function collectibleInterval(){ return 10000 + Phaser.Math.Between(-4000, 4000); }

  // ==== Gameplay helpers ====
  function endGame(s){
    if (s.gameOver) return;
    s.gameOver = true;
    try { s.tweens.killAll(); } catch {}
    try { s.time.removeAllEvents(); } catch {}
    s.throwing = false; s.arms?.setVisible(false); s.arms?.anims?.stop();
    s.physics.world.pause(); s.player.anims.pause();
    s.obstacles.children.each(o => { if (o.body) o.body.enable = false; });
    s.shurikens.children.each(b => { if (b.body) b.body.enable = false; });
    s.collectibles.children.each(c => { if (c.body) c.body.enable = false; });
    stopBlink(s); s.superBanner?.setVisible(false); s.player.clearTint();
    s.invincible=false; s.speedMult=1.0;
    finalScoreEl.textContent = Math.floor(s.score);
    show(gameover);
  }
  function zapObstacle(s,o){ if (!o || !o.active) return; o.setTint(0x99fffd); s.time.delayedCall(40, ()=>{ if (o.active) o.destroy(); }); s.score += 2; }

  const POWERUP_SPEED_MULT = 5.0, POWERUP_DURATION_MS = 6000, POWERUP_WARN_MS = 1000;
  function activatePowerUp(s){
    if (s.invincible){
      s._powerupTimer?.remove(false); s._warnTimer?.remove(false); stopBlink(s);
      s._powerupTimer = s.time.delayedCall(POWERUP_DURATION_MS, ()=>deactivatePowerUp(s));
      s._warnTimer    = s.time.delayedCall(Math.max(0, POWERUP_DURATION_MS - POWERUP_WARN_MS), ()=>startBlink(s));
      s.trailParticles?.start(); if (s._obstacleCollider) s._obstacleCollider.active = false; return;
    }
    s.invincible = true; s.speedMult=POWERUP_SPEED_MULT; s.player.setTint(0x8ef1ff);
    s.superBanner.setVisible(true); s.trailParticles?.start();
    if (s._obstacleCollider) s._obstacleCollider.active = false;
    rescaleMoversForSpeedChange(s,s._prevSpeedMult,s.speedMult);
    s._powerupTimer = s.time.delayedCall(POWERUP_DURATION_MS, ()=>deactivatePowerUp(s));
    s._warnTimer    = s.time.delayedCall(Math.max(0, POWERUP_DURATION_MS - POWERUP_WARN_MS), ()=>startBlink(s));
  }
  function deactivatePowerUp(s){
    s.invincible=false; s.speedMult=1.0; s.player.clearTint();
    s.superBanner.setVisible(false); s.trailParticles?.stop();
    if (s._obstacleCollider) s._obstacleCollider.active = true;
    s._powerupTimer?.remove(false); s._warnTimer?.remove(false); stopBlink(s);
    rescaleMoversForSpeedChange(s,s._prevSpeedMult,s.speedMult);
  }
  function startBlink(s){
    stopBlink(s);
    s._blinkTweenPlayer = s.tweens.add({ targets: s.player, alpha: 0.45, duration: 120, yoyo: true, repeat: Math.ceil(POWERUP_WARN_MS/240)*2 });
    s._blinkTweenBanner = s.tweens.add({ targets: s.superBanner, alpha: 0.4, duration: 120, yoyo: true, repeat: Math.ceil(POWERUP_WARN_MS/240)*2 });
  }
  function stopBlink(s){ s._blinkTweenPlayer?.stop(); s._blinkTweenBanner?.stop(); s._blinkTweenPlayer=null; s._blinkTweenBanner=null; s.player?.setAlpha(1); s.superBanner?.setAlpha(0.9); }
  function rescaleMoversForSpeedChange(s,prevMult,newMult){
    if (prevMult===newMult) return; const k=newMult/prevMult;
    s.obstacles.children.each(o=>{ if (o.active&&o.body&&o.body.velocity) o.body.velocity.x*=k; });
    s.collectibles.children.each(c=>{ if (c.active&&c.body&&c.body.velocity) c.body.velocity.x*=k; });
    s.shurikens.children.each(b=>{ if (b.active&&b.body&&b.body.velocity) b.body.velocity.x*=k; });
    s._prevSpeedMult = newMult;
  }

  // Spawners — all grounded things use onGround(...).setY(GROUND.y)
  function createGroundEnemy(s){
    const e = s.obstacles.create(W + sx(20), GROUND.y, 'enemyRun', 0)
      .setOrigin(0.5,1).setDepth(4.2).setScale(GEOM_SCALE);
    e.play('enemy-run');
    e.setVelocityX(-(s.worldSpeed * s.speedMult));
    e.body.setSize(ENEMY_BODY.w, ENEMY_BODY.h).setOffset(ENEMY_BODY.ox, ENEMY_BODY.oy);
    e.setData('destructible', true);
    return e;
  }
  function createCactus(s){
    const c = s.obstacles.create(W + sx(20), GROUND.y, 'cactusRect')
      .setOrigin(0.5,1).setDepth(4.2);
    c.setDisplaySize(CACTUS.w, CACTUS.h);
    c.body.setSize(CACTUS.w, CACTUS.h).setOffset(0,0);
    c.setVelocityX(-(s.worldSpeed * s.speedMult));
    c.setData('destructible', false);
    return c;
  }
  function createFlyingObstacle(s){
    const laneTop = GROUND.y - sy(0.18 * BASE.H);
    const laneBot = GROUND.y - sy(0.14 * BASE.H);
    const f = s.obstacles.create(W + sx(20), Phaser.Math.Between(laneTop,laneBot), 'ptero0')
      .setOrigin(0.5,1).setDepth(4.2);
    f.setDisplaySize(PTERO.w, PTERO.h);
    f.body.setSize(PTERO.w, PTERO.h).setOffset(0,0);
    f.play('ptero-fly');
    f.setVelocityX(-Phaser.Math.Between(s.worldSpeed-30, s.worldSpeed+50) * s.speedMult);
    f.setData('destructible', true);
    return f;
  }
  function spawnObstacle(s){ (Math.random() < GROUND_ENEMY_PROBABILITY) ? createGroundEnemy(s) : createFlyingObstacle(s); }

  function spawnCollectible(s){
    const y = Phaser.Math.Between(GROUND.y - sy(0.20 * BASE.H), GROUND.y - sy(0.15 * BASE.H));
    const item = s.collectibles.create(W + sx(20), y, 'collectible').setOrigin(0.5,0.5).setDepth(4.0);
    item.setDisplaySize(COLLECTIBLE.w, COLLECTIBLE.h);
    item.body.setSize(COLLECTIBLE.w, COLLECTIBLE.h).setOffset(0,0);
    item.setVelocityX(-(s.worldSpeed * s.speedMult));
    s.tweens.add({ targets: item, scale: 0.95, yoyo: true, duration: 400, repeat: -1 });
    return item;
  }

  function spawnShuriken(s){
    if (s.shurikens.countActive(true) >= s.shurikens.maxSize) return;
    const b = s.shurikens.get(s.player.x + THROW_OFF.x, s.player.y + THROW_OFF.y, 'shuriken');
    if (!b) return;
    b.setActive(true).setVisible(true).setOrigin(0.5);
    b.setDisplaySize(SHURIKEN.disp, SHURIKEN.disp);
    if (!b.body) s.physics.world.enable(b);
    b.body.setAllowGravity(false);
    b.body.setSize(SHURIKEN.body, SHURIKEN.body).setOffset(
      Math.round((SHURIKEN.disp - SHURIKEN.body)/2),
      Math.round((SHURIKEN.disp - SHURIKEN.body)/2)
    );
    b.setVelocityX((SHURIKEN_SPEED_BASE + s.difficulty * 20) * s.speedMult); b.setDepth(4.3);
    const SPIN=3.0, VAR=1.0; b.rotation = 0; b.rotationSpeed = (SPIN + Phaser.Math.FloatBetween(-VAR, VAR)) * Math.PI * 2;
    s.time.delayedCall(2500, ()=>{ if (b && b.active) b.destroy(); });
  }
  function doThrow(s){
    if (!s.gameStarted || s.gameOver || s.throwing) return;
    s.throwing = true;
    s.arms.setVisible(true); s.arms.anims.play('arms-throw', true);
    s.time.delayedCall(90, ()=> spawnShuriken(s));
    s.arms.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => { if (s.gameOver) return; s.throwing = false; s.arms.setVisible(false); });
  }

  // Update
  function update(time, delta){
    const s=this; if (!s.gameStarted || s.gameOver) return;

    const elapsed = s.time.now - s.startTime;
    s.difficulty = Math.min(MAX_DIFF, Math.floor(elapsed / DIFF_EVERY_MS));
    s.worldSpeed = SPEED + s.difficulty * SPEED_STEP;
    const dt = delta / 1000;

    const scroll = s.worldSpeed * s.speedMult;
    s.bgClouds.tilePositionX    += (scroll * PARALLAX.clouds)     * dt;
    s.bgMountains.tilePositionX += (scroll * PARALLAX.mountains)  * dt;
    s.bgHills.tilePositionX     += (scroll * PARALLAX.hills)      * dt;
    if (s.superBanner.visible)   s.superBanner.tilePositionX      += (scroll * 0.90) * dt;
    s.groundBack.tilePositionX  += (scroll * PARALLAX.groundBack) * dt;
    s.groundFront.tilePositionX += (scroll * PARALLAX.groundFront)* dt;

    const now = s.time.now;
    if (s.player.body.onFloor?.() || s.player.body.blocked.down) s.lastOnGroundAt = now;
    if ((s.cursors.up.isDown || s.cursors.space.isDown) && (now - s.jumpQueuedAt) > 20) s.jumpQueuedAt = now;
    const canCoyote = (now - s.lastOnGroundAt) <= COYOTE_TIME_MS;
    const hasBuffered = (now - s.jumpQueuedAt) <= JUMP_BUFFER_MS;

    if (hasBuffered && (s.player.body.blocked.down || s.player.body.onFloor?.() || canCoyote)) {
      s.player.setVelocityY(JUMP_VELOCITY);
      s.jumpQueuedAt = -Infinity;
    }
    if (s.jumpReleased && s.player.body.velocity.y < 0) {
      s.player.setVelocityY(s.player.body.velocity.y * JUMP_CUTOFF_FACTOR);
      s.jumpReleased = false;
    }

    s.shurikens.children.each(b => { if (!b.active) return; b.rotation += (b.rotationSpeed||0) * dt; if (b.x > W + sx(40)) b.destroy(); });

    if (time > s.nextSpawn) {
      spawnObstacle(s);
      const levelInterval = OBSTACLE_BASE_INTERVAL * Math.pow(INTERVAL_FACTOR, s.difficulty);
      s.nextSpawn = time + levelInterval + Phaser.Math.Between(-300, 300);
    }
    if (now > s.nextCollectible) {
      spawnCollectible(s);
      s.nextCollectible = now + collectibleInterval();
    }

    s.obstacles.children.each(o => { if (o.active && o.x < -sx(40)) { o.destroy(); s.score += (1 + s.difficulty * 0.1); } });
    s.collectibles.children.each(c => { if (c.active && c.x < -sx(40)) c.destroy(); });

    s.scoreText.setText('SCORE ' + Math.floor(s.score));
  }

  // Flow
  function toControls() { hide(splash1); show(splash2); }
  splash1Next.addEventListener('click', toControls);
  splash1.addEventListener('click', (e)=>{ if (e.target === splash1) toControls(); });
  window.addEventListener('keydown', (e)=>{ if (splash1.classList.contains('show') && (e.code==='Space' || e.code==='Enter')) toControls(); });

  function startRun() {
    const s = scene; if (!s) return;
    hide(splash2);
    s.gameOver = false; s.gameStarted = true;
    s.jumpQueuedAt = -Infinity; s.jumpReleased = false; s.lastOnGroundAt = s.time.now;
    s.physics.world.resume(); s.player.anims.play('base-run', true); s.player.anims.resume();
    s.startTime = s.time.now; s.nextSpawn = 0; s.nextCollectible = s.time.now + collectibleInterval();
  }
  startCTA.addEventListener('click', startRun);
  splash2.addEventListener('click', (e)=>{ if (e.target === splash2) startRun(); });
  window.addEventListener('keydown', (e)=>{ if (splash2.classList.contains('show') && (e.code==='Space' || e.code==='Enter')) startRun(); });

  function restartRun() {
    const s = scene; if (!s) return;
    hide(gameover);
    try { s.tweens.killAll(); } catch {} ; try { s.time.removeAllEvents(); } catch {}
    s.obstacles.clear(true, true); s.collectibles.clear(true, true); s.shurikens.clear(true, true);
    s.player.body.enable = true; s.player.setActive(true).setVisible(true); s.player.setPosition(sx(120), GROUND.y);
    s.player.setVelocity(0, 0); s.player.setAlpha(1).clearTint();
    s.throwing = false; s.arms?.setVisible(false); s.arms?.anims?.stop();
    s.invincible=false; s.speedMult=1.0; s._prevSpeedMult=1.0;
    s.score=0; s.scoreText.setText('SCORE 0'); s.difficulty=0; s.worldSpeed=SPEED;
    s.startTime = s.time.now; s.nextSpawn=0; s.nextCollectible = s.time.now + collectibleInterval();
    s.gameOver=false; s.gameStarted=true; s._obstacleCollider && (s._obstacleCollider.active = true);
    s.jumpQueuedAt=-Infinity; s.jumpReleased=false; s.lastOnGroundAt = s.time.now;
    s.physics.world.resume(); s.player.anims.play('base-run', true); s.player.anims.resume();
  }
  restartCTA.addEventListener('click', restartRun);
  gameover.addEventListener('click', (e)=>{ if (e.target === gameover) restartRun(); });
  window.addEventListener('keydown', (e)=>{ if (gameover.classList.contains('show') && e.code === 'Space') restartRun(); });

  // Fullscreen & rotate UX
  async function lockLandscape() { try { await screen.orientation?.lock?.('landscape'); } catch {} }
  async function enterFullscreen() { try { if (outer.requestFullscreen) await outer.requestFullscreen({ navigationUI: 'hide' }); else if (outer.webkitRequestFullscreen) outer.webkitRequestFullscreen(); await lockLandscape(); outer.classList.add('fs'); game.scale.refresh(); } catch { outer.classList.add('fs'); window.scrollTo(0,1); game.scale.refresh(); } }
  async function exitFullscreen() { try { if (document.fullscreenElement) await document.exitFullscreen(); else if (document.webkitFullscreenElement) document.webkitExitFullscreen?.(); } catch {} outer.classList.remove('fs'); game.scale.refresh(); }
  fsBtn.addEventListener('click', async () => { if (!document.fullscreenElement && !document.webkitFullscreenElement) await enterFullscreen(); else await exitFullscreen(); });
  document.addEventListener('fullscreenchange', () => { const fs = !!document.fullscreenElement || !!document.webkitFullscreenElement; outer.classList.toggle('fs', fs); game.scale.refresh(); });

  function updateUX() {
    const onMobile = isMobile(); const showRotate = onMobile && isPortrait();
    rotate.classList.toggle('show', showRotate);
    fsBtn.classList.toggle('show', onMobile);
    try { if (!scene) return; if (showRotate && scene.gameStarted && !scene.gameOver) scene.physics.world.pause(); else if (!showRotate && scene.gameStarted && !scene.gameOver) scene.physics.world.resume(); } catch {}
  }
  window.addEventListener('resize', () => { updateUX(); game.scale.refresh(); });
  window.addEventListener('orientationchange', () => { updateUX(); game.scale.refresh(); });
  window.addEventListener('pageshow', updateUX);

  // Boot
  updateUX();
})();
</script>
</body>
</html>
