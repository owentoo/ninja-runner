<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Ninja Runner — Mobile-Safe Start + Hard Ramp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <style>
    html, body { height: 100%; margin: 0; background: #d9d9d9; }
    #game-outer { position: relative; width: 100svw; height: 100svh; display:flex; align-items:center; justify-content:center; overflow:hidden; background:transparent; }
    #stage { position:relative; width:min(100%,1100px); aspect-ratio:1280/592; height:auto; display:grid; place-items:center; background:#d9d9d9; box-shadow:inset 0 0 0 2px #b5b5b5; border-radius:6px; }
    #game-outer.fs #stage { width:100svw; height:100svh; aspect-ratio:auto; border-radius:0; box-shadow:none; }
    canvas { display:block; }

    .overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:10; text-align:center; background:rgba(0,0,0,.60); backdrop-filter:blur(4px); pointer-events:auto; }
    .overlay.show { display:flex; }
    .sheet { max-width:560px; padding:18px 16px; border-radius:14px; background:rgba(0,0,0,.78); color:#fff; border:1px solid rgba(255,255,255,.18); font:600 14px/1.5 system-ui,-apple-system,Segoe UI,Roboto; }
    .sheet h2 { margin:0 0 8px; font-size:20px; }
    .sheet p { margin:8px 0; font-weight:500; }
    .cta { margin-top:12px; padding:10px 14px; border:0; border-radius:12px; font:600 14px/1 system-ui,-apple-system,Segoe UI,Roboto; background:#00b894; color:#0b1b16; cursor:pointer; }

    #fs-btn { position:absolute; right:10px; top:10px; z-index:11; padding:8px 10px; border:0; border-radius:12px; font:12px/1 system-ui,-apple-system,Segoe UI,Roboto; background:#000; color:#fff; opacity:.95; cursor:pointer; display:none; touch-action:manipulation; }
    #fs-btn.show { display:inline-block; }

    .hint { font:12px/1.4 monospace; color:#333; text-align:center; padding:6px 10px; background:#f2f2f2; }
    #rotate-overlay .sheet { background:rgba(0,0,0,.85); }
    /* non-blocking rotate hint while running */
    #rotate-overlay.running { pointer-events:none; background:rgba(0,0,0,.18); }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game-outer">
    <div id="stage">
      <canvas id="game"></canvas>

      <!-- Splash 1 -->
      <div id="splash-1" class="overlay show">
        <div class="sheet">
          <h2>Ninja Runner</h2>
          <p>Tap the screen or press <b>Space</b> to begin</p>
          <p style="opacity:.75;margin-top:4px;">(You’ll see the controls next)</p>
          <button id="splash-1-next" class="cta" style="margin-top:12px;">Continue</button>
        </div>
      </div>

      <!-- Splash 2 (controls) -->
      <div id="splash-2" class="overlay">
        <div class="sheet">
          <h2>How to Play</h2>
          <p>Jump: <b>↑</b> / <b>Space</b> / <b>Tap Left Half</b> (short tap = short hop; long press = higher jump)</p>
          <p>Throw: <b>X</b> / <b>Tap Right Half</b></p>
          <p>Restart: <b>Space</b> (desktop) or <b>Tap</b> (mobile)</p>
          <button id="start-cta" class="cta">Start</button>
        </div>
      </div>

      <!-- Game Over -->
      <div id="gameover" class="overlay">
        <div class="sheet">
          <h2>Game Over</h2>
          <p>Your Score: <b id="final-score">0</b></p>
          <button id="restart-cta" class="cta">Restart</button>
        </div>
      </div>

      <!-- Rotate notice (mobile portrait) -->
      <div id="rotate-overlay" class="overlay" role="dialog" aria-live="assertive">
        <div class="sheet">
          <h2>Rotate to Landscape</h2>
          <p>Turn your device sideways, or tap Fullscreen.</p>
        </div>
      </div>

      <button id="fs-btn" aria-label="Enter fullscreen">⤢ Fullscreen</button>
    </div>
  </div>

  <div class="hint">↑/SPACE = jump • X/right half = throw • Space/Tap to restart</div>

<script>
(() => {
  // ======= URL Modes =======
  const params = new URLSearchParams(location.search);
  const MODE = (params.get('mode')||'classic').toLowerCase(); // classic | hard | endless

  // ======= DESIGN SPACE & SCALERS =======
  const W = 1280, H = 592;
  const BASE = { W: 1280, H: 592 };
  const sx = (n) => Math.round(n * (W / BASE.W));
  const sy = (n) => Math.round(n * (H / BASE.H));
  const su = (n) => Math.round(n * (H / BASE.H));
  const GROUND_RATIO = 0.833;
  const GROUND_Y = Math.round(H * GROUND_RATIO);

  // ======= GAME CONSTANTS (tougher ramp, same jump forgiveness) =======
  const SPEED = 300, GRAVITY = 1400, JUMP_VELOCITY = -520;

  // Ramp by mode
  const MODE_MULT = MODE==='hard' ? 1.15 : MODE==='endless' ? 1.25 : 1.0;
  const OBSTACLE_BASE_INTERVAL = Math.round(980 / MODE_MULT);
  const MAX_DIFF_BASE = MODE==='endless' ? 16 : 12;
  const MAX_DIFF = MAX_DIFF_BASE;
  const DIFF_EVERY_MS = Math.round(8000 / MODE_MULT);
  const SPEED_STEP = Math.round(34 * MODE_MULT);
  const INTERVAL_FACTOR = 0.88;

  // Combat / mix
  const SHURIKEN_SPEED_BASE = 650;
  const GROUND_ENEMY_PROBABILITY = 0.45;

  // Parallax
  const PARALLAX = { clouds:0.20, mountains:0.35, hills:0.55, groundBack:0.95, groundFront:1.15 };

  // Jump forgiveness unchanged per request
  const COYOTE_TIME_MS = 120, JUMP_BUFFER_MS = 120, JUMP_CUTOFF_FACTOR = 0.5;

  const SHURIKEN_DISPLAY = su(20), SHURIKEN_BODY = su(16);
  const THROW_OFFSET = { x: sx(14), y: -sy(38) };

  // Powerups
  const POWERUP_SPEED_MULT = 5.0, POWERUP_DURATION_MS = 4000, POWERUP_WARN_MS = 900;
  const COLLECTIBLE_BASE_INTERVAL = 13500, COLLECTIBLE_INTERVAL_JITTER = 4500;

  // DPR
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // DOM refs
  const outer = document.getElementById('game-outer');
  const rotate = document.getElementById('rotate-overlay');
  const splash1 = document.getElementById('splash-1');
  const splash2 = document.getElementById('splash-2');
  const gameover = document.getElementById('gameover');
  const splash1Next = document.getElementById('splash-1-next');
  const startCTA = document.getElementById('start-cta');
  const restartCTA = document.getElementById('restart-cta');
  const fsBtn = document.getElementById('fs-btn');
  const finalScoreEl = document.getElementById('final-score');

  const isMobile   = () => /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent);
  const isPortrait = () => window.matchMedia('(orientation: portrait)').matches;

  // ======= Phaser (single instance) =======
  let game;
  let scene; // cached reference after boot

  game = new Phaser.Game({
    type: Phaser.AUTO,                       // WEBGL first, falls back to CANVAS
    render: { roundPixels: true, powerPreference: 'high-performance' },
    backgroundColor: '#87ceeb',
    canvas: document.getElementById('game'),
    resolution: DPR,
    physics: { default: 'arcade', arcade: { gravity: { y: GRAVITY }, debug: false } },
    scale: {
      parent: 'stage', width: W, height: H,
      mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH,
      fullscreenTarget: 'game-outer',
      expandParent: true
    },
    scene: { preload, create, update }
  });

  // ======= Helper for overlays =======
  const show = (el) => el.classList.add('show');
  const hide = (el) => el.classList.remove('show');

  // ======= PLACEHOLDERS / LOADING =======
  function solid(scene, key, w, h, color){const g=scene.add.graphics();g.fillStyle(color,1).fillRect(0,0,w,h);g.generateTexture(key,w,h);g.destroy();}
  function makePattern(scene,key,w,h,base,stripe,step=6,a=0.18){const g=scene.add.graphics();g.fillStyle(base,1).fillRect(0,0,w,h);g.lineStyle(1,stripe,a);for(let y=step;y<h;y+=step)g.strokeLineShape(new Phaser.Geom.Line(0,y,w,y));g.generateTexture(key,w,h);g.destroy();}
  function makeCrate(scene){const k='crateRect',w=48,h=48,b=1;const g=scene.add.graphics();g.fillStyle(0x8a6f3b,1).fillRect(0,0,w,h);g.lineStyle(3,0x3f2d14,1).strokeRect(b,b,w-2*b,h-2*b);g.generateTexture(k,w,h);g.destroy();}
  function makeCollectibleTex(scene){const k='collectible',size=20;const g=scene.add.graphics();g.fillStyle(0xfff066,1).fillCircle(size/2,size/2,size/2);g.lineStyle(2,0xffb200,1).strokeCircle(size/2,size/2,(size/2)-1);g.generateTexture(k,size,size);g.destroy();}

  function preload(){
    solid(this,'px',2,2,0x000000);
    this.load.image('bgClouds','bg_clouds.png');
    this.load.image('bgMountains','bg_mountains.png');
    this.load.image('bgHills','bg_hills.png');
    this.load.image('groundBackTile','ground_back_tile.png');
    this.load.image('groundFrontTile','ground_front_tile.png');
    this.load.spritesheet('ninjaRun','ninja_run.png',{frameWidth:48,frameHeight:55});
    this.load.spritesheet('enemyRun','ninja_run_enemy.png',{frameWidth:48,frameHeight:55});
    this.load.image('shuriken','shuriken.png');
    this.load.image('superBanner','super.png');

    for (let i=0;i<2;i++) solid(this,'arms'+i,48,48,0xff8a8a);
    for (let i=0;i<2;i++) solid(this,'armsThrow'+i,48,48,0xff5252);
    solid(this,'cactusRect',16,26,0x000000);
    makeCrate(this);
    for (let i=0;i<2;i++) solid(this,'ptero'+i,48,24,0x000000);
    makeCollectibleTex(this);
    this.load.image('collectible','collectible.png');
  }

  function ensureBGAndGroundTextures(s){
    if (!s.textures.exists('bgClouds'))    makePattern(s,'bgClouds',256,Math.round(H*0.135),0xffffff,0x000000,8,0.10);
    if (!s.textures.exists('bgMountains')) makePattern(s,'bgMountains',256,Math.round(H*0.152),0xa0b1c2,0x000000,10,0.12);
    if (!s.textures.exists('bgHills'))     makePattern(s,'bgHills',256,Math.round(H*0.118),0x7b8fa6,0x000000,8,0.12);
    if (!s.textures.exists('groundBackTile'))  makePattern(s,'groundBackTile',128,Math.round(H*0.030),0x8b5a2b,0x000000,6,0.18);
    if (!s.textures.exists('groundFrontTile')) makePattern(s,'groundFrontTile',128,Math.round(H*0.047),0x6b3f1f,0x000000,6,0.20);
  }

  // ======= Fairness helper =======
  function minSafeGap(s){
    const runSpeed = s.worldSpeed * s.speedMult;
    const jumpAirTime = Math.abs(JUMP_VELOCITY) / GRAVITY * 2; // simple ballistic estimate
    const react = 0.35; // reaction buffer
    return Math.round((runSpeed * (jumpAirTime + react)) + sx(80));
  }

  // ======= Scene =======
  let sessionDeathsQuick = 0;
  let sessionLongRun = false;

  function create(){
    const s=this; scene = s; ensureBGAndGroundTextures(s);

    // State
    s.gameStarted=false; s.gameOver=false; s.throwing=false; s.score=0;
    s.difficulty=0; s.worldSpeed=SPEED; s.startTime=s.time.now;
    s.speedMult=1.0; s._prevSpeedMult=1.0; s.invincible=false;

    // Layers
    s.bgClouds    = s.add.tileSprite(0, Math.round(H*0.10), W*2, Math.round(H*0.135),'bgClouds').setOrigin(0,0).setDepth(0);
    s.bgMountains = s.add.tileSprite(0, Math.round(H*0.152),W*2, Math.round(H*0.152),'bgMountains').setOrigin(0,0).setDepth(1);
    s.bgHills     = s.add.tileSprite(0, Math.round(H*0.22), W*2, Math.round(H*0.118),'bgHills').setOrigin(0,0).setDepth(2);

    s.superBanner = s.add.tileSprite(0,0,W*2,GROUND_Y,'superBanner')
      .setOrigin(0,0).setDepth(2.6).setVisible(false).setAlpha(0.9);

    s.groundBack  = s.add.tileSprite(0, GROUND_Y- sy(8),  W*2, sy(18), 'groundBackTile').setOrigin(0,0).setDepth(3.0);
    s.groundFront = s.add.tileSprite(0, GROUND_Y- sy(2),  W*2, sy(28), 'groundFrontTile').setOrigin(0,0).setDepth(3.2);

    const floor = s.physics.add.staticImage(W/2, GROUND_Y+1, 'px').setDisplaySize(W, sy(4)).refreshBody();

    // Player +100px right
    s.player = s.physics.add.sprite(sx(220), GROUND_Y, 'ninjaRun', 0).setOrigin(0.5,1).setCollideWorldBounds(true);
    s.player.body.setSize(su(36), su(50)).setOffset(su(6), su(5));
    s.physics.add.collider(s.player, floor);
    s.player.setDepth(4.5);

    // Anims
    s.anims.create({ key: 'base-run', frames: s.anims.generateFrameNumbers('ninjaRun', { start: 0, end: 7 }), frameRate: 12, repeat: -1 });
    s.anims.create({ key:'enemy-run', frames: s.anims.generateFrameNumbers('enemyRun', { start: 0, end: 7 }), frameRate: 12, repeat: -1 });
    s.anims.create({ key:'arms-throw',frames:[{key:'armsThrow0'},{key:'armsThrow1'}], frameRate:12, repeat:0 });
    s.anims.create({ key:'ptero-fly', frames:[{key:'ptero0'},{key:'ptero1'}], frameRate:8, repeat:-1 });

    s.player.play('base-run'); s.player.anims.pause();

    s.arms = s.add.sprite(s.player.x, s.player.y, 'arms0').setOrigin(0.5,1).setDepth(4.6).setVisible(false);
    s.events.on('update', ()=>{ s.arms.x = s.player.x; s.arms.y = s.player.y; });

    // Particles (for power)
    s.trailParticles = s.add.particles(0, 0, 'px', {
      lifespan: 220, speed: 0, quantity: 1, frequency: 22,
      scale: { start: 1.1, end: 0 }, alpha: { start: 0.65, end: 0 },
      tint: 0x8ef1ff, follow: s.player, blendMode: 'ADD'
    }); s.trailParticles.stop();

    // Pools
    s.obstacles   = s.physics.add.group({ allowGravity:false, immovable:true, maxSize: 80, runChildUpdate:false });
    s.collectibles= s.physics.add.group({ allowGravity:false, immovable:true, maxSize: 12, runChildUpdate:false });
    s.shurikens   = s.physics.add.group({ maxSize: 12 });

    // Inputs
    s.cursors = s.input.keyboard.createCursorKeys();
    const keyX = s.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.X);

    // Touch jump: short tap = short hop; long press = higher jump
    s.touchJumpPointerId = null; s.jumpHeldByTouch = false; s.touchWasLeftHalf = false;
    let touchDownX = 0;

    s.input.on('pointerdown', (pointer) => {
      if (!s.gameStarted || s.gameOver) return;
      const isLeft = pointer.worldX < (W * 0.5);
      touchDownX = pointer.worldX;
      if (isLeft) {
        s.touchJumpPointerId = pointer.id;
        s.touchWasLeftHalf = true;
        s.jumpHeldByTouch = true;
        s.jumpQueuedAt = s.time.now;
        s.jumpReleased = false;
      } else {
        doThrow(s);
      }
    });

    s.input.on('pointerup', (pointer) => {
      if (!s.gameStarted || s.gameOver) return;
      const moved = Math.abs(pointer.worldX - touchDownX);
      if (pointer.id === s.touchJumpPointerId && s.touchWasLeftHalf && moved < sx(40)) {
        s.jumpReleased = true;
      }
      s.jumpHeldByTouch = false; s.touchWasLeftHalf = false; s.touchJumpPointerId = null;
    });

    s.input.keyboard.on('keydown-UP',    ()=>{ if (s.gameStarted) s.jumpQueuedAt = s.time.now; });
    s.input.keyboard.on('keydown-SPACE', ()=>{
      if (!s.gameStarted && !s.gameOver && splash2.classList.contains('show')) { startRun(); return; }
      if (s.gameOver) { restartRun(); return; }
      if (s.gameStarted) s.jumpQueuedAt = s.time.now;
    });
    keyX.on('down', () => { if (s.gameStarted) doThrow(s); });

    s.lastOnGroundAt = s.time.now; s.jumpQueuedAt = -Infinity; s.jumpReleased = false;
    s.input.keyboard.on('keyup-UP',    ()=>{ s.jumpReleased = true; });
    s.input.keyboard.on('keyup-SPACE', ()=>{ s.jumpReleased = true; });

    // HUD (Top-right)
    s.scoreText = s.add.text(W - sx(180), sy(12), 'SCORE 0', { fontFamily:'monospace', fontSize:16, color:'#000' }).setDepth(10).setOrigin(0,0);
    s.speedText = s.add.text(W - sx(180), sy(32), 'Speed× 1.0', { fontFamily:'monospace', fontSize:12, color:'#000' }).setDepth(10).setOrigin(0,0);

    // Collisions
    s._obstacleCollider = s.physics.add.collider(s.player, s.obstacles, (player, o) => { if (!s.invincible) endGame(s); });
    s.physics.add.overlap(s.player, s.obstacles, (player, o) => { if (s.invincible) zapObstacle(s, o); });
    s.physics.add.overlap(s.shurikens, s.obstacles, (b,o)=>{
      if (!b.active || !o.active) return;
      if (o.getData('hit')) { b.destroy(); return; }
      b.destroy();
      if (o.getData('destructible')) {
        o.setData('hit', true); o.setTint(0xffff66);
        s.cameras.main.shake(60, 0.004);
        s.time.delayedCall(60, ()=>{ if (o.active) o.disableBody(true, true); s.score += (3 + s.difficulty * 0.5); });
      }
    });
    s.physics.add.overlap(s.player, s.collectibles, (player, item)=>{
      if (!item.active) return; item.disableBody(true, true); activatePowerUp(s);
    });

    s.nextSpawn = 0;
    s.nextCollectible = s.time.now + collectibleInterval();

    // Start paused under overlays until Start
    s.physics.world.pause();

    // Pause on visibility change (fairness), but never because of rotate once running
    document.addEventListener('visibilitychange', ()=> {
      if (!scene) return;
      if (document.hidden && s.gameStarted && !s.gameOver) s.physics.world.pause();
      if (!document.hidden && s.gameStarted && !s.gameOver && !isPortrait()) s.physics.world.resume();
    });
    window.addEventListener('blur', ()=>{ if (s.gameStarted && !s.gameOver) s.physics.world.pause(); });
    window.addEventListener('focus',()=>{ if (s.gameStarted && !s.gameOver && !isPortrait()) s.physics.world.resume(); });
  }

  function collectibleInterval(){ return COLLECTIBLE_BASE_INTERVAL + Phaser.Math.Between(-COLLECTIBLE_INTERVAL_JITTER, COLLECTIBLE_INTERVAL_JITTER); }

  // ======= End / Powerups / Helpers =======
  function endGame(s){
    if (s.gameOver) return;
    s.gameOver = true;
    try { s.tweens.killAll(); } catch {}
    try { s.time.removeAllEvents(); } catch {}

    s.throwing = false;
    if (s.arms) { s.arms.setVisible(false); s.arms.anims?.stop(); }

    s.physics.world.pause();
    s.player.anims.pause();
    s.obstacles.children.each(o => { if (o.body) o.body.enable = false; });
    s.shurikens.children.each(b => { if (b.body) b.body.enable = false; });
    s.collectibles.children.each(c => { if (c.body) c.body.enable = false; });

    stopBlink(s);
    s.superBanner?.setVisible(false);
    s.player.clearTint();
    s.invincible=false; s.speedMult=1.0;

    const runtime = (s.time.now - s.startTime);
    if (runtime < 15000) sessionDeathsQuick++; else sessionDeathsQuick = Math.max(0, sessionDeathsQuick-1);
    if (runtime >= 60000) sessionLongRun = true;

    finalScoreEl.textContent = Math.floor(s.score);
    show(gameover);
  }

  function zapObstacle(s,o){ if (!o || !o.active) return; o.setTint(0x99fffd); s.time.delayedCall(40, ()=>{ if (o.active) o.disableBody(true, true); }); s.score += 2; }

  function activatePowerUp(s){
    if (s.invincible){
      if (s._powerupTimer) s._powerupTimer.remove(false);
      if (s._warnTimer) s._warnTimer.remove(false);
      stopBlink(s);
      s._powerupTimer = s.time.delayedCall(POWERUP_DURATION_MS, ()=>deactivatePowerUp(s));
      s._warnTimer    = s.time.delayedCall(Math.max(0, POWERUP_DURATION_MS - POWERUP_WARN_MS), ()=>startBlink(s));
      if (s.trailParticles) s.trailParticles.start();
      if (s._obstacleCollider) s._obstacleCollider.active = false;
      return;
    }
    s.invincible = true; s.speedMult=POWERUP_SPEED_MULT; s.player.setTint(0x8ef1ff);
    s.superBanner.setVisible(true); if (s.trailParticles) s.trailParticles.start();
    if (s._obstacleCollider) s._obstacleCollider.active = false;
    rescaleMoversForSpeedChange(s,s._prevSpeedMult,s.speedMult);
    s._powerupTimer = s.time.delayedCall(POWERUP_DURATION_MS, ()=>deactivatePowerUp(s));
    s._warnTimer    = s.time.delayedCall(Math.max(0, POWERUP_DURATION_MS - POWERUP_WARN_MS), ()=>startBlink(s));
  }
  function deactivatePowerUp(s){
    s.invincible=false; s.speedMult=1.0; s.player.clearTint();
    s.superBanner.setVisible(false); if (s.trailParticles) s.trailParticles.stop();
    if (s._obstacleCollider) s._obstacleCollider.active = true;
    if (s._powerupTimer) s._powerupTimer.remove(false);
    if (s._warnTimer) s._warnTimer.remove(false);
    stopBlink(s);
    rescaleMoversForSpeedChange(s,s._prevSpeedMult,s.speedMult);
  }
  function startBlink(s){
    stopBlink(s);
    s._blinkTweenPlayer = s.tweens.add({ targets: s.player, alpha: 0.45, duration: 120, yoyo: true, repeat: Math.ceil(POWERUP_WARN_MS/240)*2 });
    s._blinkTweenBanner = s.tweens.add({ targets: s.superBanner, alpha: 0.4, duration: 120, yoyo: true, repeat: Math.ceil(POWERUP_WARN_MS/240)*2 });
    const oldScale = s.time.timeScale; s.time.timeScale = 0.85;
    s.time.delayedCall(400, ()=>{ s.time.timeScale = oldScale; });
  }
  function stopBlink(s){ 
    if (s._blinkTweenPlayer){ s._blinkTweenPlayer.stop(); s._blinkTweenPlayer=null; }
    if (s._blinkTweenBanner){ s._blinkTweenBanner.stop(); s._blinkTweenBanner=null; }
    if (s.player) s.player.setAlpha(1);
    if (s.superBanner) s.superBanner.setAlpha(0.9);
  }
  function rescaleMoversForSpeedChange(s,prevMult,newMult){
    if (prevMult===newMult) return; const k=newMult/prevMult;
    s.obstacles.children.each(o=>{ if (o.active&&o.body&&o.body.velocity) o.body.velocity.x*=k; });
    s.collectibles.children.each(c=>{ if (c.active&&c.body&&c.body.velocity) c.body.velocity.x*=k; });
    s.shurikens.children.each(b=>{ if (b.active&&b.body&&b.body.velocity) b.body.velocity.x*=k; });
    s._prevSpeedMult = newMult;
  }

  function getObstacleFromPool(s, key, x, y){
    const obj = s.obstacles.get(x, y, key);
    obj.setActive(true).setVisible(true);
    obj.body.enable = true;
    return obj;
  }

  function createGroundObstacle(s){
    const makeEnemy = Math.random() < GROUND_ENEMY_PROBABILITY;
    const xSpawn = W + Math.max(sx(20), minSafeGap(s));
    if (makeEnemy){
      const e = getObstacleFromPool(s, 'enemyRun', xSpawn, GROUND_Y).setOrigin(0.5,1).setDepth(4.2);
      e.play('enemy-run');
      const extra = 20 + s.difficulty * 6;
      e.setVelocityX(-(s.worldSpeed + extra) * s.speedMult);
      e.body.setSize(su(36), su(50)).setOffset(su(6), su(5));
      e.setData('destructible', true).setTint(0xffffff).setData('hit', false);
      return e;
    } else {
      const c = getObstacleFromPool(s, 'cactusRect', xSpawn, GROUND_Y).setOrigin(0.5,1).setDepth(4.2);
      c.setDisplaySize(su(16), su(26));
      c.body.setSize(su(16), su(26)).setOffset(0,0);
      c.setVelocityX(-(s.worldSpeed * s.speedMult));
      c.setData('destructible', false).setTint(0xffffff).setData('hit', false);
      return c;
    }
  }

  function createFlyingObstacle(s){
    const laneTop = GROUND_Y - sy(0.22 * BASE.H);
    const laneBot = GROUND_Y - sy(0.12 * BASE.H);
    const xSpawn = W + Math.max(sx(20), minSafeGap(s));
    const f = getObstacleFromPool(s, 'ptero0', xSpawn, Phaser.Math.Between(laneTop,laneBot))
      .setOrigin(0.5,1).setDepth(4.2);
    f.setDisplaySize(su(48), su(24));
    f.body.setSize(su(48), su(24)).setOffset(0,0);
    f.play('ptero-fly');
    const extra = 40 + s.difficulty * 8;
    f.setVelocityX(-(s.worldSpeed + extra) * s.speedMult);
    f.setData('destructible', true).setTint(0xffffff).setData('hit', false);
    return f;
  }

  function spawnObstacle(s){
    const flyWeight = Math.min(0.25 + s.difficulty * 0.05, 0.75);
    (Math.random() < flyWeight) ? createFlyingObstacle(s) : createGroundObstacle(s);
  }

  function spawnCollectible(s){
    const y = Phaser.Math.Between(GROUND_Y - sy(0.20 * BASE.H), GROUND_Y - sy(0.15 * BASE.H));
    const xSpawn = W + Math.max(sx(20), minSafeGap(s));
    const item = s.collectibles.get(xSpawn, y, 'collectible').setOrigin(0.5,0.5).setDepth(4.0);
    item.setActive(true).setVisible(true); item.body.enable = true;
    item.setDisplaySize(su(20), su(20));
    item.body.setSize(su(20), su(20)).setOffset(0,0);
    item.setVelocityX(-(s.worldSpeed * s.speedMult));
    item.setScale(1.1);
    s.tweens.add({ targets: item, scale: 1.0, yoyo: true, duration: 400, repeat: -1 });
    return item;
  }

  function spawnShuriken(s){
    if (s.shurikens.countActive(true) >= s.shurikens.maxSize) return;
    const b = s.shurikens.get(s.player.x + THROW_OFFSET.x, s.player.y + THROW_OFFSET.y, 'shuriken');
    if (!b) return;
    b.setActive(true).setVisible(true).setOrigin(0.5);
    b.setDisplaySize(SHURIKEN_DISPLAY, SHURIKEN_DISPLAY);
    if (!b.body) s.physics.world.enable(b);
    b.body.setAllowGravity(false);
    b.body.setSize(SHURIKEN_BODY, SHURIKEN_BODY).setOffset(
      Math.round((SHURIKEN_DISPLAY - SHURIKEN_BODY)/2),
      Math.round((SHURIKEN_DISPLAY - SHURIKEN_BODY)/2)
    );
    const speed = (SHURIKEN_SPEED_BASE + s.difficulty * 20) * s.speedMult;
    b.setVelocityX(speed); b.setDepth(4.3);
    const SPIN = 3.0, VAR = 1.0;
    b.rotation = 0;
    b.rotationSpeed = (SPIN + Phaser.Math.FloatBetween(-VAR, VAR)) * Math.PI * 2;
    s.time.delayedCall(2500, ()=>{ if (b && b.active) b.destroy(); });
  }

  function doThrow(s){
    if (!s.gameStarted || s.gameOver || s.throwing) return;
    s.throwing = true;
    s.arms.setVisible(true); s.arms.anims.play('arms-throw', true);
    s.time.delayedCall(90, ()=> spawnShuriken(s));
    s.arms.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
      if (s.gameOver) return;
      s.throwing = false;
      s.arms.setVisible(false);
    });
  }

  // ======= Update =======
  function update(time, delta){
    const s=this;
    if (!s.gameStarted || s.gameOver) return;

    // adaptive: raise cap if long run
    const maxDiff = sessionLongRun ? MAX_DIFF + 1 : MAX_DIFF;

    const elapsed = s.time.now - s.startTime;
    // ease-in if player died quickly twice
    const startPenalty = sessionDeathsQuick >= 2 ? -1 : 0;
    const baseDiff = Math.floor(elapsed / DIFF_EVERY_MS) + Math.max(0, startPenalty);
    s.difficulty = Math.min(maxDiff, Math.max(0, baseDiff));
    s.worldSpeed = SPEED + s.difficulty * SPEED_STEP;
    const dt = delta / 1000;

    const scroll = s.worldSpeed * s.speedMult;
    s.bgClouds.tilePositionX    += (scroll * PARALLAX.clouds)     * dt;
    s.bgMountains.tilePositionX += (scroll * PARALLAX.mountains)  * dt;
    s.bgHills.tilePositionX     += (scroll * PARALLAX.hills)      * dt;
    if (s.superBanner.visible)   s.superBanner.tilePositionX      += (scroll * 0.90) * dt;
    s.groundBack.tilePositionX  += (scroll * PARALLAX.groundBack) * dt;
    s.groundFront.tilePositionX += (scroll * PARALLAX.groundFront)* dt;

    const now = s.time.now;
    if (s.player.body.blocked.down) s.lastOnGroundAt = now;
    if ((s.cursors.up.isDown || s.cursors.space.isDown) && (now - s.jumpQueuedAt) > 20) s.jumpQueuedAt = now;
    const canCoyote = (now - s.lastOnGroundAt) <= COYOTE_TIME_MS;
    const hasBuffered = (now - s.jumpQueuedAt) <= JUMP_BUFFER_MS;

    if (hasBuffered && (s.player.body.blocked.down || canCoyote)) {
      s.player.setVelocityY(JUMP_VELOCITY);
      s.jumpQueuedAt = -Infinity;
    }
    if (s.jumpReleased && s.player.body.velocity.y < 0) {
      s.player.setVelocityY(s.player.body.velocity.y * JUMP_CUTOFF_FACTOR);
      s.jumpReleased = false;
    }

    s.shurikens.children.each(b => {
      if (!b.active) return;
      b.rotation += (b.rotationSpeed||0) * dt;
      if (b.x > W + sx(40)) b.destroy();
    });

    if (time > s.nextSpawn) {
      telegraphBurst(s);
      spawnObstacle(s);

      const levelInterval = OBSTACLE_BASE_INTERVAL * Math.pow(INTERVAL_FACTOR, s.difficulty);

      const burstChance = Math.min(0.15 + s.difficulty * 0.06, 0.65);
      if (Math.random() < burstChance) {
        const delay = Phaser.Math.Between(160, 320);
        s.time.delayedCall(delay, () => { if (!s.gameOver && s.gameStarted) spawnObstacle(s); });
        if (Math.random() < 0.25 && s.difficulty >= 6) {
          s.time.delayedCall(delay + Phaser.Math.Between(140, 240), () => { if (!s.gameOver && s.gameStarted) spawnObstacle(s); });
        }
      }

      s.nextSpawn = time + levelInterval + Phaser.Math.Between(-260, 260);
    }

    if (now > s.nextCollectible) {
      spawnCollectible(s);
      s.nextCollectible = now + collectibleInterval();
    }

    s.obstacles.children.each(o => { if (o.active && o.x < -sx(40)) { o.disableBody(true, true); s.score += (1 + s.difficulty * 0.1); } });
    s.collectibles.children.each(c => { if (c.active && c.x < -sx(40)) c.disableBody(true, true); });

    s.scoreText.setText('SCORE ' + Math.floor(s.score));
    const sp = (s.worldSpeed/300).toFixed(2);
    s.speedText.setText('Speed× ' + sp);
  }

  function telegraphBurst(s){
    s.tweens.add({ targets: s.groundFront, alpha: 0.85, duration: 80, yoyo: true, repeat: 1, onComplete:()=>{ s.groundFront.setAlpha(1); }});
  }

  // ======= Flow (full-panel overlays) =======
  function toControls() { hide(splash1); show(splash2); }
  splash1Next.addEventListener('click', toControls);
  splash1.addEventListener('click', (e)=>{ if (e.target === splash1) toControls(); });
  window.addEventListener('keydown', (e)=>{ if (splash1.classList.contains('show') && (e.code==='Space' || e.code==='Enter')) toControls(); });

  function startRun() {
    const s = scene; if (!s) return;
    hide(splash2);

    s.gameOver = false;
    s.gameStarted = true;

    // Make absolutely sure physics and animation resume:
    s.physics.world.resume();
    s.player.anims.play('base-run', true);
    s.player.anims.resume();

    s.jumpQueuedAt = -Infinity;
    s.jumpReleased = false;
    s.lastOnGroundAt = s.time.now;

    s.startTime = s.time.now;
    s.nextSpawn = 0;
    s.nextCollectible = s.time.now + collectibleInterval();

    // Try to enter fullscreen on mobile (non-blocking)
    if (isMobile() && !document.fullscreenElement && !document.webkitFullscreenElement) {
      (async () => {
        try {
          if (outer.requestFullscreen) await outer.requestFullscreen({ navigationUI: 'hide' });
          else if (outer.webkitRequestFullscreen) outer.webkitRequestFullscreen();
          try { await screen.orientation?.lock?.('landscape'); } catch {}
          outer.classList.add('fs');
          game.scale.refresh();
        } catch {}
      })();
    }

    updateUX(); // mark rotate hint as non-blocking while running
  }
  startCTA.addEventListener('click', startRun);
  splash2.addEventListener('click', (e)=>{ if (e.target === splash2) startRun(); });
  window.addEventListener('keydown', (e)=>{ if (splash2.classList.contains('show') && (e.code==='Space' || e.code==='Enter')) startRun(); });
  // Global “start anyway” failsafe: click stage to proceed/start
  document.getElementById('stage').addEventListener('click', () => {
    if (splash1.classList.contains('show')) { hide(splash1); show(splash2); return; }
    if (splash2.classList.contains('show')) { startRun(); return; }
  });

  function restartRun() {
    const s = scene; if (!s) return;
    hide(gameover);
    try { s.tweens.killAll(); } catch {}
    try { s.time.removeAllEvents(); } catch {}

    s.obstacles.children.each(o=>o.disableBody(true,true));
    s.collectibles.children.each(c=>c.disableBody(true,true));
    s.shurikens.clear(true, true);

    s.player.body.enable = true;
    s.player.setActive(true).setVisible(true);
    s.player.setPosition(sx(220), GROUND_Y);
    s.player.setVelocity(0, 0);
    s.player.setAlpha(1).clearTint();

    s.throwing = false;
    if (s.arms) { s.arms.setVisible(false); s.arms.anims?.stop(); }

    s.invincible = false; s.speedMult = 1.0; s._prevSpeedMult = 1.0;
    s.score = 0; s.scoreText.setText('SCORE 0');
    s.difficulty = 0; s.worldSpeed = SPEED;

    s.startTime = s.time.now;
    s.nextSpawn = 0; s.nextCollectible = s.time.now + collectibleInterval();
    s.gameOver = false; s.gameStarted = true;
    if (s._obstacleCollider) s._obstacleCollider.active = true;

    s.jumpQueuedAt = -Infinity;
    s.jumpReleased = false;
    s.lastOnGroundAt = s.time.now;

    s.physics.world.resume();
    s.player.anims.play('base-run', true);
    s.player.anims.resume();

    updateUX();
  }
  restartCTA.addEventListener('click', restartRun);
  gameover.addEventListener('click', (e)=>{ if (e.target === gameover) restartRun(); });
  window.addEventListener('keydown', (e)=>{ if (gameover.classList.contains('show') && e.code === 'Space') restartRun(); });

  // ======= Fullscreen (no rebuild) =======
  async function lockLandscape() { try { await screen.orientation?.lock?.('landscape'); } catch {} }
  async function enterFullscreen() {
    try {
      if (outer.requestFullscreen) await outer.requestFullscreen({ navigationUI: 'hide' });
      else if (outer.webkitRequestFullscreen) outer.webkitRequestFullscreen();
      await lockLandscape();
      outer.classList.add('fs');
      game.scale.refresh();
    } catch {
      outer.classList.add('fs');
      window.scrollTo(0,1);
      game.scale.refresh();
    }
  }
  async function exitFullscreen() {
    try {
      if (document.fullscreenElement) await document.exitFullscreen();
      else if (document.webkitFullscreenElement) document.webkitExitFullscreen?.();
    } catch {}
    outer.classList.remove('fs');
    game.scale.refresh();
  }
  fsBtn.addEventListener('click', async () => {
    if (!document.fullscreenElement && !document.webkitFullscreenElement) await enterFullscreen();
    else await exitFullscreen();
  });
  document.addEventListener('fullscreenchange', () => {
    const fs = !!document.fullscreenElement || !!document.webkitFullscreenElement;
    outer.classList.toggle('fs', fs);
    game.scale.refresh();
  });

  // ======= Rotate/UX – never pause a running game =======
  function updateUX() {
    const onMobile = isMobile();
    const portrait = isPortrait();

    // Show rotate overlay:
    // - before starting a run, it blocks (to encourage landscape)
    // - after run starts, it's a non-blocking hint (no pause)
    const allowBlocking = !scene || !scene.gameStarted || scene.gameOver;
    const showRotate = onMobile && portrait;

    rotate.classList.toggle('show', showRotate);
    rotate.classList.toggle('running', showRotate && !allowBlocking && scene && scene.gameStarted && !scene.gameOver);
    fsBtn.classList.toggle('show', onMobile);

    try {
      if (!scene) return;
      // Only pause because of rotate BEFORE starting a run
      if (allowBlocking && showRotate) {
        scene.physics.world.pause();
      } else if (scene.gameStarted && !scene.gameOver) {
        scene.physics.world.resume();
      }
    } catch {}
  }
  window.addEventListener('resize', () => { updateUX(); game.scale.refresh(); });
  window.addEventListener('orientationchange', () => { updateUX(); game.scale.refresh(); });
  window.addEventListener('pageshow', updateUX);

  // ======= Boot UX =======
  updateUX();
})();
</script>
</body>
</html>
