<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Ninja Runner — Destructible Ground Targets</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:#f2f2f2; }
    #game { width:100%; max-width:900px; margin:0 auto; display:block; }
    .hint { max-width:900px; margin:8px auto; font:12px/1.4 monospace; color:#333; padding:0 6px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<canvas id="game"></canvas>
<div class="hint">↑/SPACE = jump • X/click = throw • R = restart</div>

<script>
(() => {
  // --- Constants (fixed) ---
  const FRAME = { w: 48, h: 48, ptero: { w: 48, h: 24 } };
  const W = 800, H = 300, GROUND_Y = 250;
  const SPEED = 300, GRAVITY = 1400, JUMP_VELOCITY = -520;
  const OBSTACLE_BASE_INTERVAL = 1200;

  // Difficulty constants
  const MAX_DIFF = 8;
  const DIFF_EVERY_MS = 15000;
  const SPEED_STEP = 25;
  const INTERVAL_FACTOR = 0.92;

  // Projectiles
  const SHURIKEN_SPEED_BASE = 600;

  // Mix: probability a ground obstacle is a shootable "crate" instead of an indestructible cactus
  const CRATE_PROBABILITY = 0.45; // ← tweak this (0.0–1.0)

  new Phaser.Game({
    type: Phaser.CANVAS,
    width: W, height: H, backgroundColor: '#ffffff',
    canvas: document.getElementById('game'),
    physics: { default: 'arcade', arcade: { gravity: { y: GRAVITY }, debug: false } },
    scene: { preload, create, update }
  });

  // ---------- helpers to make textures ----------
  function makeRectTexture(scene, key, w, h, color, label) {
    const g = scene.add.graphics();
    g.fillStyle(color, 1).fillRect(0,0,w,h);
    g.lineStyle(2, 0x222222, 1).strokeRect(1,1,w-2,h-2);
    if (label !== undefined) {
      const txt = scene.add.text(0,0, String(label), { fontFamily: 'monospace', fontSize: 12, color: '#000' });
      txt.setPosition((w - txt.width)/2, (h - txt.height)/2);
      const rt = scene.make.renderTexture({ x:0, y:0, width:w, height:h, add:false });
      rt.draw(g,0,0); rt.draw(txt,0,0);
      rt.saveTexture(key);
      txt.destroy(); g.destroy(); rt.destroy();
      return;
    }
    g.generateTexture(key, w, h);
    g.destroy();
  }

  function makeCrateTexture(scene, key, w, h) {
    const g = scene.add.graphics();
    // body
    g.fillStyle(0x8a6f3b, 1).fillRect(0,0,w,h);
    // border + planks
    g.lineStyle(2, 0x3f2d14, 1).strokeRect(1,1,w-2,h-2);
    g.lineStyle(1, 0x3f2d14, 1);
    g.strokeLineShape(new Phaser.Geom.Line(3, h-10, w-3, h-10));
    g.strokeLineShape(new Phaser.Geom.Line(3, 10, w-3, 10));
    g.strokeLineShape(new Phaser.Geom.Line(6, 3, 6, h-3));
    g.strokeLineShape(new Phaser.Geom.Line(w-6, 3, w-6, h-3));
    g.generateTexture(key, w, h);
    g.destroy();
  }

  function preload() {
    // 2×2 px for ground/bullets
    const g = this.add.graphics();
    g.fillStyle(0x000000, 1).fillRect(0, 0, 2, 2);
    g.generateTexture('px', 2, 2);
    g.destroy();

    // Self-generated placeholder frames (no external PNGs)
    for (let i=0;i<4;i++) makeRectTexture(this, 'base'+i, FRAME.w, FRAME.h, 0x7db8ff, i);      // base run 0..3
    for (let i=0;i<2;i++) makeRectTexture(this, 'arms'+i, FRAME.w, FRAME.h, 0xff8a8a, i);      // arms run 0..1
    for (let i=0;i<2;i++) makeRectTexture(this, 'armsThrow'+i, FRAME.w, FRAME.h, 0xff5252, i); // arms throw 0..1
    makeRectTexture(this, 'cactusRect', 16, 26, 0x000000);                                     // cactus (indestructible)
    makeCrateTexture(this, 'crateRect', 18, 20);                                               // crate (destructible)
    for (let i=0;i<2;i++) makeRectTexture(this, 'ptero'+i, FRAME.ptero.w, FRAME.ptero.h, 0x000000); // flying 0..1
  }

  function create() {
    const s = this;

    // Scene-scoped state (robust restart)
    s.gameOver   = false;
    s.throwing   = false;
    s.score      = 0;
    s.difficulty = 0;
    s.worldSpeed = SPEED;
    s.startTime  = s.time.now;

    // Ground & floor
    s.ground = s.add.tileSprite(0, GROUND_Y+10, W*2, 2, 'px').setOrigin(0,0.5).setTint(0x333333);
    const floor = s.physics.add.staticImage(W/2, GROUND_Y+1, 'px').setDisplaySize(W,4).refreshBody();

    // Player (base has physics; arms overlays)
    s.player = s.physics.add.sprite(120, GROUND_Y, 'base0').setOrigin(0.5,1).setCollideWorldBounds(true);
    s.player.body.setSize(36,44).setOffset(6,4);
    s.physics.add.collider(s.player, floor);

    s.arms = s.add.sprite(s.player.x, s.player.y, 'arms0').setOrigin(0.5,1).setDepth(s.player.depth+1);
    s.events.on('update', () => { s.arms.x = s.player.x; s.arms.y = s.player.y; });

    // Anims
    s.anims.create({ key:'base-run',  frames:[{key:'base0'},{key:'base1'},{key:'base2'},{key:'base3'}], frameRate:10, repeat:-1 });
    s.anims.create({ key:'arms-run',  frames:[{key:'arms0'},{key:'arms1'}], frameRate:10, repeat:-1 });
    s.anims.create({ key:'arms-throw',frames:[{key:'armsThrow0'},{key:'armsThrow1'}], frameRate:12, repeat:0 });
    s.anims.create({ key:'ptero-fly', frames:[{key:'ptero0'},{key:'ptero1'}], frameRate:8, repeat:-1 });

    // Physics groups
    s.obstacles = s.physics.add.group({ allowGravity:false, immovable:true });
    s.shurikens = s.physics.add.group({ maxSize: 12 });

    // Input
    s.cursors = s.input.keyboard.createCursorKeys();
    const keyX = s.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.X);
    const keyR = s.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
    s.input.on('pointerdown', () => doThrow(s));
    keyX.on('down', () => doThrow(s));
    keyR.on('down', () => { if (s.gameOver) s.scene.restart(); });

    // UI
    s.scoreText   = s.add.text(14, 12, 'SCORE 0', { fontFamily:'monospace', fontSize:16, color:'#000' });
    s.gameOverTxt = s.add.text(W/2, H/2 - 10, '', { fontFamily:'monospace', fontSize:20, color:'#000' }).setOrigin(0.5);
    s.restartTxt  = s.add.text(W/2, H/2 + 16, '', { fontFamily:'monospace', fontSize:14, color:'#000' }).setOrigin(0.5);

    // Collisions
    s.physics.add.overlap(s.shurikens, s.obstacles, (b,o)=>{
      // Only destroy obstacles that are destructible
      if (o.getData('destructible')) {
        b.destroy();
        // tiny hit flash
        o.setTint(0xffff66);
        s.time.delayedCall(60, () => { o.destroy(); s.score += (3 + s.difficulty * 0.5); });
      } else {
        // shuriken poofs on cactus
        b.destroy();
      }
    });

    s.physics.add.collider(s.player, s.obstacles, () => endGame(s));

    // Spawner bookkeeping
    s.nextSpawn = 0;

    // Start anims
    s.player.play('base-run');
    s.arms.play('arms-run');
  }

  // ---- Scene helpers ----
  function endGame(s) {
    if (s.gameOver) return;
    s.gameOver = true;
    s.physics.world.pause();
    s.gameOverTxt.setText('GAME OVER');
    s.restartTxt.setText('Press R to Restart');
  }

  function createGroundObstacle(s) {
    // Decide cactus (indestructible) or crate (destructible)
    const makeCrate = Math.random() < CRATE_PROBABILITY;
    const key = makeCrate ? 'crateRect' : 'cactusRect';
    const o = s.obstacles.create(W + 20, GROUND_Y, key).setOrigin(0.5,1).setVelocityX(-s.worldSpeed);
    o.setData('destructible', !!makeCrate);
    return o;
  }

  function createFlyingObstacle(s) {
    const f = s.obstacles.create(W + 20, Phaser.Math.Between(GROUND_Y-110, GROUND_Y-60), 'ptero0').setOrigin(0.5,1);
    f.play('ptero-fly');
    f.setVelocityX(-Phaser.Math.Between(s.worldSpeed-30, s.worldSpeed+50));
    f.setData('destructible', false); // flying stays unshootable here (can change later)
    return f;
  }

  function spawnObstacle(s) {
    (Math.random() < 0.65) ? createGroundObstacle(s) : createFlyingObstacle(s);
  }

  function spawnShuriken(s) {
    const THROW_OFFSET = { x: 14, y: -38 };
    const sx = s.player.x + THROW_OFFSET.x;
    const sy = s.player.y + THROW_OFFSET.y;
    const b = s.shurikens.get(sx, sy, 'px');
    if (!b) return;
    const shurikenSpeed = SHURIKEN_SPEED_BASE + s.difficulty * 20;
    b.setActive(true).setVisible(true).setDisplaySize(6,6);
    s.physics.world.enable(b);
    b.body.setAllowGravity(false);
    b.setVelocityX(shurikenSpeed);
  }

  function doThrow(s) {
    if (s.gameOver || s.throwing) return;
    s.throwing = true;
    s.arms.anims.play('arms-throw', true);
    s.time.delayedCall(90, ()=> spawnShuriken(s));
    s.arms.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
      s.throwing = false;
      if (s.player.body.blocked.down) s.arms.anims.play('arms-run', true);
    });
  }

  function update(time, delta) {
    const s = this;
    if (s.gameOver) return;

    // Difficulty progression
    const elapsed = s.time.now - s.startTime;
    s.difficulty = Math.min(MAX_DIFF, Math.floor(elapsed / DIFF_EVERY_MS));
    s.worldSpeed = SPEED + s.difficulty * SPEED_STEP;

    // Scroll ground
    s.ground.tilePositionX += (s.worldSpeed * delta / 1000);

    // Jump
    if ((s.cursors.up.isDown || s.cursors.space.isDown) && s.player.body.blocked.down) {
      s.player.setVelocityY(JUMP_VELOCITY);
    }

    // Spawn with difficulty-scaled interval
    if (time > s.nextSpawn) {
      spawnObstacle(s);
      const levelInterval = OBSTACLE_BASE_INTERVAL * Math.pow(INTERVAL_FACTOR, s.difficulty);
      s.nextSpawn = time + levelInterval + Phaser.Math.Between(-300, 300);
    }

    // Cleanup & passive score
    s.shurikens.children.each(b => { if (b.active && b.x > W + 40) b.destroy(); });
    s.obstacles.children.each(o => {
      if (o.active && o.x < -40) {
        o.destroy();
        // small travel bonus regardless of type
        s.score += (1 + s.difficulty * 0.1);
      }
    });

    // UI
    s.scoreText.setText('SCORE ' + Math.floor(s.score));
  }
})();
</script>
</body>
</html>
